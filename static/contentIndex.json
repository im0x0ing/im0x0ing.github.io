{"index":{"slug":"index","filePath":"index.md","title":"ğŸ  é¦–é¡µ","links":["about"],"tags":[],"content":"æ¬¢è¿æ¥åˆ° ING wikiï¼\næŒç»­å»ºè®¾ä¸­â€¦\nğŸ“‚ å¯¼èˆª\n\nå…³äºæˆ‘\n\nğŸ“ æœ€è¿‘æ›´æ–°\n\nè¿™é‡Œå¯ä»¥å†™ä¸€äº›æœ€è¿‘çš„æƒ³æ³•æˆ–è€…ç½®é¡¶çš„å†…å®¹ã€‚\n"},"å·¥å…·ä½¿ç”¨/Obsidianæ’ä»¶":{"slug":"å·¥å…·ä½¿ç”¨/Obsidianæ’ä»¶","filePath":"å·¥å…·ä½¿ç”¨/Obsidianæ’ä»¶.md","title":"Obsidianæ’ä»¶","links":[],"tags":[],"content":"templater\nå¯ä»¥æŠŠTemplatesæ–‡ä»¶å¤¹ä¸‹çš„ç¬”è®°ä½œä¸ºæ¨¡æ¿,å·¦ä¾§åŠŸèƒ½æ ç‚¹å‡»å³å¯å¥—ç”¨åˆ°å…¶ä»–ç¬”è®°ä¸Š.ä¸ä¼šå½±å“å·²å†™çš„å†…å®¹.\nConsistent Attachments and Links\nå³é”®æŸä¸ªæ–‡ä»¶å¤¹,å¯ä»¥ä»æ•´ä¸ªä»“åº“æ”¶é›†å±äºè¯¥æ–‡ä»¶å¤¹ä¸‹ç¬”è®°çš„å›¾ç‰‡,å¹¶æ”¾åˆ°è¯¥æ–‡ä»¶å¤¹ä¸‹çš„attachmentsæ–‡ä»¶å¤¹ä¸­.\n\né¦–å…ˆè¦åœ¨obsidianè®¾ç½®-æ–‡ä»¶ä¸é“¾æ¥-é™„ä»¶é»˜è®¤å­˜æ”¾è·¯å¾„,ç¡®å®šå¥½é™„ä»¶å­˜æ”¾æ–¹å¼æ˜¯åœ¨æ–‡ä»¶å¤¹ä¸‹çš„attachmentsæ–‡ä»¶å¤¹.\nä½¿ç”¨æ—¶,æ¯”å¦‚å…ˆç§»åŠ¨äº†ä¸€ä¸ªç¬”è®°,ç„¶åå³é”®ç¬”è®°æ‰€å±æ–‡ä»¶å¤¹å³å¯é€‰æ‹©collect attachments.[æ³¨æ„ä¸è¦å¯¹é™„ä»¶æ–‡ä»¶å¤¹åšä»»ä½•åˆ é™¤æ“ä½œ,è¿™ä¸ªç§»åŠ¨æ˜¯é™„ä»¶æœ¬ä½“è¿›è¡Œç§»åŠ¨,ä¸æ˜¯å‰¯æœ¬ç§»åŠ¨]\n\nGit\nå¥½ç”¨,å¯ä»¥æŠŠæ•´ä¸ªobsidianä»“åº“æ‰˜ç®¡åˆ°gitç„¶åè®¾ç½®æ¯ä¸¤å°æ—¶æäº¤ä¸€æ¬¡(å¦‚æœæœ‰ä¿®æ”¹çš„è¯).æˆ‘ä¹‹å‰ç¢ç£¨é™„ä»¶æ’ä»¶çš„æ—¶å€™æŠŠé™„ä»¶åˆ æ²¡äº†å…¨é gitæ‰¾å›æ¥(å½“ç„¶ä¹Ÿå¯ä»¥å»å›æ”¶ç«™æ‰¾)\nShell Commands\nå¯ä»¥ç¼–å†™ç»ˆç«¯æŒ‡ä»¤.ä½¿ç”¨ä¾‹:\n\nç¼–å†™äº†ä¸€ä¸ªæŒ‡ä»¤,æ¯æ¬¡Obsidianæ‰“å¼€çš„æ—¶å€™ä¼šè‡ªåŠ¨è¿›å…¥æˆ‘çš„åšå®¢æœ¬åœ°ä»“åº“è¿›è¡Œä¸€æ¬¡å‘å¸ƒ.\n"},"å·¥å…·ä½¿ç”¨/åšå®¢æ­å»º":{"slug":"å·¥å…·ä½¿ç”¨/åšå®¢æ­å»º","filePath":"å·¥å…·ä½¿ç”¨/åšå®¢æ­å»º.md","title":"åšå®¢æ­å»º","links":[],"tags":[],"content":"åŸºäºObsidianå’ŒQuartz4.æµç¨‹:\n\nå°†quartz4ä»“åº“å…‹éš†åˆ°æœ¬åœ°.ç„¶åå°†contentæ–‡ä»¶å¤¹é‡å®šå‘åˆ°æœ¬åœ°obsidianä»“åº“çš„publicæ–‡ä»¶å¤¹.è¿™æ ·ä¸¤è¾¹çš„å†…å®¹ä¼šè¿›è¡Œä¸€ä¸ªåŒæ­¥.\nä¸ºæœ¬åœ°quartzä»“åº“é…ç½®ç§é’¥å’Œå…¬é’¥.ç§é’¥é“¾æ¥åˆ°githubç§æœ‰ä»“åº“.å…¬é’¥è¿æ¥åˆ°githubå…¬æœ‰ä»“åº“.è¿™æ ·åªæœ‰é™æ€äº§ç‰©ä¼šdeployåˆ°å…¬æœ‰ä»“åº“,å°†å…¬æœ‰ä»“åº“åå­—è®¾ç½®ä¸ºusername.github.ioå³å¯.\nåœ¨obsidianä¸­çš„Publicæ–‡ä»¶å¤¹ä¸‹ä¹¦å†™ç¬”è®°,ç„¶ååœ¨quartz4æœ¬åœ°ä»“åº“è¿›è¡Œæäº¤.è¿™æ ·ä¹‹åç§æœ‰ä»“åº“[åšå®¢æºç ]ä¼šæ›´æ–°.å…¬æœ‰ä»“åº“[é™æ€äº§ç‰©]ä¹Ÿä¼šæ›´æ–°,æœ€ç»ˆä½“ç°åœ¨åšå®¢ç½‘é¡µä¸Š.\n\nè¯„è®º\ngiscus åŸºäºgithubä»“åº“discussion\ntips\n\nquartz.config.ts-&gt;plugins -&gt; transformers\nåŠ ä¸Šä¸€è¡ŒPlugin.HardLineBreaks(),,å°±ä¼šè°ƒç”¨remark-breaks è¿™ä¸ªåº“,å°†æ‰€æœ‰æ¢è¡Œå¼ºåˆ¶æ¸²æŸ“æˆ&lt;br&gt;,å¦åˆ™ç¬”è®°é‡Œé¢çš„æœ¬æ¥çš„æ¢è¡Œé€‰ç„¶åä¼šå˜æˆç©ºæ ¼.[åªæœ‰ä¸¤æ¬¡å›è½¦/ä¸¤ä¸ªç©ºæ ¼ä¸€æ¬¡å›è½¦ä¼šè¢«æ¸²æŸ“æˆæ¢è¡Œä½†æ˜¯å¤ªéº»çƒ¦äº†æ‰€ä»¥]\n"},"æŠ€æœ¯ç§¯ç´¯/Golang/04-sliceåˆ‡ç‰‡åŠ¨æ€æ•°ç»„ç±»å‹":{"slug":"æŠ€æœ¯ç§¯ç´¯/Golang/04-sliceåˆ‡ç‰‡åŠ¨æ€æ•°ç»„ç±»å‹","filePath":"æŠ€æœ¯ç§¯ç´¯/Golang/04 sliceåˆ‡ç‰‡åŠ¨æ€æ•°ç»„ç±»å‹.md","title":"04 sliceåˆ‡ç‰‡åŠ¨æ€æ•°ç»„ç±»å‹","links":[],"tags":[],"content":"tips\n// åŸå†™æ³•  s := []byte{} å¾—åˆ°çš„ä¸æ˜¯nilåˆ‡ç‰‡\n// æ›¿ä»£å†™æ³• var s []byte å¾—åˆ°çš„æ˜¯nilåˆ‡ç‰‡,ä½†æ˜¯å¯ä»¥ç…§å¸¸append goè‡ªå·±ä¼šå¤„ç†\nä¹Ÿå¯ä»¥s := make([]byte, 0)\n//æ³¨æ„åˆ‡ç‰‡æ˜¯å·¦é—­å³å¼€,\nå›ºå®šé•¿åº¦æ•°ç»„array\nä½†æ˜¯åœ¨goä¸­ä¸ç­‰åŒäºå…¶ä»–è¯­è¨€æ•°ç»„çš„åœ°ä½,å¯ä»¥è¯´sliceæ‰æ˜¯goè¯­è¨€çš„æ•°ç»„.\n\næ ¹æ®ç´¢å¼•åˆå§‹åŒ– æ³¨æ„é»˜è®¤å€¼æ˜¯0\næŸ¥çœ‹æ•°ç»„çš„æ•°æ®ç±»å‹ï¼šé•¿åº¦å˜æˆäº†ç±»å‹çš„ä¸€éƒ¨åˆ†,å› æ­¤å­˜åœ¨ä¸¤ä¸ªé—®é¢˜\n\nå› æ­¤ä¼ å‚çš„æ—¶å€™ä¹Ÿè¦åŒºåˆ†ä¸åŒé•¿åº¦çš„æ•°ç»„äº†\nè€Œä¸”ä»ç„¶æ˜¯ä¸€ä¸ªå€¼ä¼ é€’ï¼ˆæŠŠæœ¬æ¥çš„æ•°ç»„æ‹·è´ç»™å½¢å‚ï¼Œæ‰€ä»¥è¿˜æ˜¯ä¼šæœ‰ä¹‹å‰é‚£ä¸ªå†…å­˜å’Œåœ°å€çš„é—®é¢˜ï¼Œæ‰€ä»¥ä¸èƒ½è¿›è¡Œæ”¹åŠ¨ï¼‰\n\n\næ‰€ä»¥è¯´è¦ä¼ å‚çš„è¯æœ€å¥½è¿˜æ˜¯å†™åŠ¨æ€æ•°ç»„,ä¹Ÿå¯ä»¥ä½¿ç”¨åˆ‡ç‰‡æ“ä½œç¬¦ [:] ä½ å¯ä»¥æŠŠæ•°ç»„â€œåˆ‡â€ä¸€ä¸‹,è¿™é‡Œæ˜¯åˆ›å»ºä¸€ä¸ªå¼•ç”¨ ä¸æ˜¯copy,ç›¸å½“äºä¼ äº†åœ°å€\n\nrangeå…³é”®å­—\næ ¹æ®éå†ä¸åŒé›†åˆè¿”å›ä¸åŒå€¼ã€‚\n\næ•°ç»„æˆ–åˆ‡ç‰‡\n\nè¿”å›ä¸¤ä¸ªå€¼  å½“å‰å…ƒç´ æ‰€åœ¨ç´¢å¼•å’Œå½“å‰å…ƒç´ å€¼æœ¬èº«å¦‚æœä¸å…³å¿ƒæŸä¸ªè¿”å›å€¼çš„è¯å¯ä»¥æŠŠå®ƒè®¾ç½®æˆåŒ¿å\n\n\n\nåŠ¨æ€æ•°ç»„:åˆ‡ç‰‡ slice\næ•°æ®ç»“æ„\nè¿ç»­çš„å†…å­˜,æœ¬èº«åªåŒ…å«ä¸‰ä¸ªä¿¡æ¯(å¯ä»¥åœ¨runtimeåŒ…ä¸‹æŸ¥è¯¢)\ntype slice struct {\n    // æŒ‡å‘èµ·ç‚¹çš„åœ°å€\n    array unsafe.Pointer\n    // åˆ‡ç‰‡é•¿åº¦\n    len   int\n    // åˆ‡ç‰‡å®¹é‡\n    cap   int\n}\n\næŒ‡é’ˆ ç¬¬ä¸€ä¸ªå…ƒç´ çš„å†…å­˜åœ°å€\né•¿åº¦ å½“å‰å­˜æ”¾çš„å…ƒç´ ä¸ªæ•°  è®¿é—®åˆ‡ç‰‡æ˜¯å¦åˆæ³•\nå®¹é‡ æ€»å…±èƒ½è£…å¤šå°‘ä¸ªå…ƒç´ (æå‰åˆ†é…çš„ç©ºé—´å…ƒç´ ä¸ªæ•°),capæ°¸è¿œå¤§äºç­‰äºlen è€ƒè™‘æ€§èƒ½ä¼˜åŒ–\n\n\nç´¢å¼•æ—¶åªéœ€è¦è®¡ç®—ç›®æ ‡åœ°å€ = èµ·å§‹åœ°å€ + ( ç´¢å¼• x æ¯ä¸ªå…ƒç´ çš„å¤§å° ),å› æ­¤æ—¶é—´å¤æ‚åº¦æ˜¯O(1)\n\nç‰¹å¾\n\nä¼ é€’æ—¶è¡¨é¢ä¸Šæ˜¯è¿›è¡Œslice headerçš„å€¼ä¼ é€’,ä½†å› ä¸ºå†…éƒ¨å­˜æ”¾çš„æ˜¯unsafe.Pointeråœ°å€,å› æ­¤å®é™…ä¸Šç›¸å½“äºå¼•ç”¨ä¼ é€’,å¯ä»¥ç›´æ¥è¿›è¡Œä¼ é€’å¹¶åœ¨å‡½æ•°ä¸­è¿›è¡Œå€¼ä¿®æ”¹.[goè¯­è¨€ä¸­æ²¡æœ‰çœŸæ­£çš„å¼•ç”¨ä¼ é€’,åŸºæœ¬éƒ½æ˜¯è¿™æ ·çš„ä¼ªå¼•ç”¨ä¼ é€’].\n\nå› æ­¤lenå’Œcapåœ¨å‡½æ•°ä¸­è¢«ä¿®æ”¹æ˜¯ä¸ä¼šåæ˜ åˆ°åº•å±‚æ•°æ®ç»“æ„çš„\n\n\næ‹¬å·é‡Œé¢æ˜¯ç©ºçš„ï¼Œè¡¨ç¤ºåŠ¨æ€ã€‚å¯ä»¥çœ‹åˆ°ç±»å‹ä¹Ÿæ˜¯åŠ¨æ€æ•°ç»„ç±»å‹\n\nsliceåˆ‡ç‰‡çš„å››ç§å£°æ˜æ–¹å¼/åˆå§‹åŒ–\n\nå£°æ˜ä½†ä¸è¿›è¡Œåˆå§‹åŒ–\n\nåˆ¤æ–­ä¸€ä¸ªsliceæ˜¯å¦ä¸ºç©ºnil [æ²¡æœ‰ç©ºé—´,è€Œå…¨0ä¸ç®—ç©º]\nç©ºsliceä¸èƒ½å¤Ÿè¿›è¡Œèµ‹å€¼,ä½†æ˜¯å¯ä»¥è¿›è¡Œappend(ç›¸å½“äºä¸€ä¸ªä¸€ä¸ªå¼€è¾Ÿç©ºé—´)\n\n\n\nvar s []init\n \n//åˆ¤æ–­ä¸€ä¸ªsliceæ˜¯å¦ä¸º0\nif  slice1 == nil{\n\tfmt.println(&quot;æ˜¯ä¸€ä¸ªç©ºåˆ‡ç‰‡&quot;)\n\t}else{\n\tfmt.println(&quot;ä¸æ˜¯ä¸€ä¸ªç©ºåˆ‡ç‰‡&quot;)}\nelseå’Œå‰åä¸¤ä¸ªæ‹¬å·éœ€è¦åœ¨åŒä¸€è¡Œå¦åˆ™ä¼šæŠ¥è¯­æ³•é”™\n\nåŸºäºmakeè¿›è¡Œåˆå§‹åŒ–\n\nåªåˆå§‹åŒ–lenè€Œä¸åˆå§‹åŒ–cap.\n\næ­¤æ—¶ä¼šå°†lenå’ŒcapåŒæ—¶é»˜è®¤è®¾ç½®ä¸ºlençš„å€¼.å› ä¸ºå¦‚æœlen&gt;capä¼šåˆå§‹åŒ–å¤±è´¥.\nåˆ‡ç‰‡çš„é•¿åº¦ä¸€æ—¦è¢«æŒ‡å®šäº†ï¼Œå°±ä»£è¡¨å¯¹åº”ä½ç½®å·²ç»è¢«åˆ†é…äº†å…ƒç´ ï¼Œè®¾ç½®çš„ä¼šæ˜¯å¯¹åº”å…ƒç´ ç±»å‹ä¸‹çš„é›¶å€¼.\n\n\nåˆ†åˆ«æŒ‡å®šlenå’Œcap\n\nåœ¨indexã€len,cap)çš„åŒºåŸŸæ— æ³•è¢«è®¿é—®,å› ä¸ºé€»è¾‘ä¸Šä¸å­˜åœ¨å…ƒç´ ,è®¿é—®ä¼šè¢«æŠ¥é”™.\n\n\n\n\n\ns := make([]int,8)\ns := make([]int,8,16)\n\n%v å¯ä»¥æ‰“å°æ•°ç»„å†…è¯¦ç»†æ•°æ®\n\n\nåˆå§‹åŒ–è¿å¸¦èµ‹å€¼\n\nä¼šå°†lenå’ŒcapåŒæ—¶è®¾ä¸º3å¹¶ä¸”å®Œæˆèµ‹å€¼\n\n\n\nÂ Â sÂ :=Â []int{2,3,4}\nåˆå§‹åŒ–æºç \nfunc makeslice(et *_type, len, cap int) unsafe.Pointer {\n    // æ ¹æ® cap ç»“åˆæ¯ä¸ªå…ƒç´ çš„å¤§å°ï¼Œè®¡ç®—å‡ºæ¶ˆè€—çš„æ€»å®¹é‡\n    mem, overflow := math.MulUintptr(et.size, uintptr(cap))\n    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {\n        // å€˜è‹¥å®¹é‡è¶…é™ï¼Œlen å–è´Ÿå€¼æˆ–è€… len è¶…è¿‡ capï¼Œç›´æ¥ panic\n        mem, overflow := math.MulUintptr(et.size, uintptr(len))\n        if overflow || mem &gt; maxAlloc || len &lt; 0 {\n            panicmakeslicelen()\n        }\n        panicmakeslicecap()\n    }\n    // èµ° mallocgc è¿›è¡Œå†…å­˜åˆ†é…ä»¥åŠåˆ‡ç‰‡åˆå§‹åŒ–,ä»¥åŠå›æ”¶\n    return mallocgc(mem, et, true)\n}\nè¿½åŠ ä¸æˆªå–\nåˆ‡ç‰‡çš„è¿½åŠ \né€šè¿‡ append æ“ä½œï¼Œå¯ä»¥åœ¨ slice çš„æœ«å°¾ï¼Œé¢å¤–æ–°å¢ä¸€ä¸ªå…ƒç´ .\n\nè¿™é‡Œçš„æœ«å°¾æŒ‡çš„æ˜¯é’ˆå¯¹ slice çš„é•¿åº¦ len è€Œè¨€.å®é™…ä¸Šæˆªå–çš„è¯,ä»èµ·ç‚¹å¼€å§‹çš„å®¹é‡ä¼šä¿ç•™,è¯¦è§è¾¨æ5\nè¿™ä¸ªè¿‡ç¨‹ä¸­å€˜è‹¥å‘ç° slice çš„å‰©ä½™capå·²ç»ä¸è¶³äº†ï¼Œåˆ™ä¼šå¯¹ slice è¿›è¡Œæ‰©å®¹.åŠ¨æ€å¼€è¾Ÿç›¸å½“äºæœ¬æ¥capçš„å®¹é‡\n\n\nåœ¨åˆ›å»º slice æ—¶ï¼Œå¦‚æœèƒ½å¤Ÿé¢„ä¼°åˆ°å…¶æœªæ¥æ‰€éœ€çš„å®¹é‡ç©ºé—´,åº”è¯¥æå‰åˆ†é…å¥½å¯¹åº”å®¹é‡ï¼Œé¿å…åœ¨è¿è¡Œè¿‡ç¨‹ä¸­é¢‘ç¹è§¦å‘æ‰©å®¹æ“ä½œï¼Œè¿™æ ·ä¼šå¯¹æ€§èƒ½äº§ç”Ÿä¸åˆ©çš„å½±å“.\n\n\nå®ä¾‹1\nå€˜è‹¥å¸Œæœ›ä½¿ç”¨ append æ“ä½œå®Œæˆ slice èµ‹å€¼ï¼Œåˆ™åº”è¯¥åœ¨åˆå§‹åŒ– slice æ—¶ï¼Œç»™å…¶è®¾ç½®ä¸åŒçš„é•¿åº¦ len å’Œå®¹é‡ cap å€¼ï¼Œcap å’Œ len ä¹‹é—´çš„å·®å€¼å°±æ˜¯é¢„ç•™å‡ºæ¥ç”¨äº append æ“ä½œçš„ç©ºé—´. å…·ä½“ä»£ç å¦‚ä¸‹ï¼š\nfunc Test_slice(t *testing.T){\n    s := make([]int,0,5)\n    for i := 0; i &lt; 5; i++{\n       s = append(s, i)//è¿½åŠ çš„å¯¹è±¡æ•°ç»„,ä»¥åŠè¿½åŠ çš„æ•°æ®\n    }\n    // ç»“æœä¸ºï¼š\n    // s: [0,1,2,3,4]\n}\nå®ä¾‹2\næˆ‘ä»¬å°† slice çš„é•¿åº¦å’Œå®¹é‡éƒ½è®¾ç½®ä¸º 5,ç„¶åé€šè¿‡éå† slice çš„æ–¹å¼è¿›è¡Œæ‰§è¡Œä½ç½®å…ƒç´ çš„èµ‹å€¼ï¼ˆä¸ä½¿ç”¨ append æ“ä½œï¼‰ï¼š\nfunc Test_slice(t *testing.T){\n    s := make([]int,5)\n    for i := 0; i &lt; 5; i++{\n       s[i] = i\n    }\n    // ç»“æœä¸ºï¼š\n    // s: [0,1,2,3,4]\n}\næ‰©å®¹\nå½“lenä¸capç›¸ç­‰æ—¶,ä¸‹ä¸€æ¬¡appendæ“ä½œå°±ä¼šè¿›è¡Œä¸€æ¬¡æ‰©å®¹\n    // len:4, cap: 4\n    s := []int{2,3,4,5}\n    // len:5, cap: 8    len=åŸæ¥çš„é•¿åº¦+1,cap=åŸæ¥çš„cap*2\n    s = append(s,6)\n\n\né¢„æœŸå®¹é‡:\n\nå¦‚æœåªè¿½åŠ ä¸€ä¸ªå…ƒç´ ,é¢„æœŸå®¹é‡å°±æ˜¯åŸæœ¬çš„å®¹é‡+1,ç±»ä¼¼çš„.\n\nè€å®¹é‡&lt;256 åˆ™æ‰©å®¹ä¸ºåŸæ¥çš„ä¸¤å€\nè€å®¹é‡&gt;256 é‚£ä¹ˆå°±è¿›å…¥ä¸€ä¸ªå¾ªç¯,æŒ‰ç…§ç‰¹æ®Šæ–¹å¼æ‰©å®¹ç›´åˆ°å¤§äºç­‰äºé¢„æœŸå®¹é‡.å¦‚æœåœ¨è¿™ä¸ªå¾ªç¯ä¸­æ•°å€¼å¤ªå¤§äº†ä»¥è‡³äºè¶Šç•Œ,é‚£ä¹ˆå°±ç›´æ¥å–é¢„æœŸæ–°å®¹é‡ä¸ºæœ€ç»ˆå€¼\n\n\nå¦‚æœé¢„æœŸå…ƒç´ æ˜¯æ¯”å¦‚ä¸€ä¸ªåˆ‡ç‰‡,é‚£ä¹ˆé¢„æœŸå®¹é‡å°±å¯èƒ½ä¼šè¶…å‡ºåŸå®¹é‡çš„ä¸¤å€.\n\n\næ ¹æ®æ•°æ®ç±»å‹æ¨ç®—å‡ºå®é™…éœ€è¦çš„å†…å­˜å¤§å°,ç„¶åmallocgcä¸­è¿˜è¦å¯¹å†…å­˜åˆ†é…å•å…ƒmspançš„ç­‰çº§åˆ¶åº¦,æ¨ç®—å¾—åˆ°å®é™…éœ€è¦ç”³è¯·çš„å†…å­˜ç©ºé—´å¤§å°(å‘ä¸Šå–æ•´)\n\nmheapæ˜¯goç®¡ç†çš„æ‰€æœ‰å†…å­˜ä¹‹å’Œ\nmspanå°±æ˜¯æ ‡å‡†å¤§å°åœ°å—,æœ‰ä¸åŒå¤§å°ç­‰çº§å…±ç¨‹åºç”³è¯·ä½¿ç”¨.\n\n\nè°ƒç”¨ mallocgcï¼Œå¯¹æ–°åˆ‡ç‰‡è¿›è¡Œå†…å­˜åˆå§‹åŒ–\nè°ƒç”¨ memmove æ–¹æ³•ï¼Œå°†è€åˆ‡ç‰‡ä¸­çš„å†…å®¹æ‹·è´åˆ°æ–°åˆ‡ç‰‡ä¸­\nè¿”å›æ‰©å®¹åçš„æ–°åˆ‡ç‰‡ã€æ‰©å®¹åä¼šå˜æˆæ–°çš„åœ°å€ã€‘\næºç :\n\nfunc growslice(et *_type, old slice, cap int) slice {\n    //... \n    if cap &lt; old.cap {\n        panic(errorString(&quot;growslice: cap out of range&quot;))\n    }\n \n \n    if et.size == 0 {\n        // å€˜è‹¥å…ƒç´ å¤§å°ä¸º 0ï¼Œåˆ™æ— éœ€åˆ†é…ç©ºé—´ç›´æ¥è¿”å›\n        return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}\n    }\n \n \n    // è®¡ç®—æ‰©å®¹åæ•°ç»„çš„å®¹é‡\n    newcap := old.cap\n    // å–åŸå®¹é‡ä¸¤å€çš„å®¹é‡æ•°å€¼\n    doublecap := newcap + newcap\n    // å€˜è‹¥æ–°çš„å®¹é‡å¤§äºåŸå®¹é‡çš„ä¸¤å€ï¼Œç›´æ¥å–æ–°å®¹é‡ä½œä¸ºæ•°ç»„æ‰©å®¹åçš„å®¹é‡\n    if cap &gt; doublecap {\n        newcap = cap\n    } else {\n        const threshold = 256\n        // å€˜è‹¥åŸå®¹é‡å°äº 256ï¼Œåˆ™æ‰©å®¹åæ–°å®¹é‡ä¸ºåŸå®¹é‡çš„ä¸¤å€\n        if old.cap &lt; threshold {\n            newcap = doublecap\n        } else {\n            // åœ¨åŸå®¹é‡çš„åŸºç¡€ä¸Šï¼Œå¯¹åŸå®¹é‡ * 5/4 å¹¶ä¸”åŠ ä¸Š 192\n            // å¾ªç¯æ‰§è¡Œä¸Šè¿°æ“ä½œï¼Œç›´åˆ°æ‰©å®¹åçš„å®¹é‡å·²ç»å¤§äºç­‰äºé¢„æœŸçš„æ–°å®¹é‡ä¸ºæ­¢\n            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {             \n                newcap += (newcap + 3*threshold) / 4\n            }\n            // å€˜è‹¥æ•°å€¼è¶Šç•Œäº†ï¼Œåˆ™å–é¢„æœŸçš„æ–°å®¹é‡ cap å°é¡¶\n            if newcap &lt;= 0 {\n                newcap = cap\n            }\n        }\n    }\n \n \n    var overflow bool\n    var lenmem, newlenmem, capmem uintptr\n    // åŸºäºå®¹é‡ï¼Œç¡®å®šæ–°æ•°ç»„å®¹å™¨æ‰€éœ€è¦çš„å†…å­˜ç©ºé—´å¤§å° capmem\n    switch {\n    // å€˜è‹¥æ•°ç»„å…ƒç´ çš„å¤§å°ä¸º 1ï¼Œåˆ™æ–°å®¹é‡å¤§å°ä¸º 1 * newcap.\n    // åŒæ—¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´\n    case et.size == 1:\n        lenmem = uintptr(old.len)\n        newlenmem = uintptr(cap)\n        capmem = roundupsize(uintptr(newcap))\n        overflow = uintptr(newcap) &gt; maxAlloc\n        newcap = int(capmem)\n    // å€˜è‹¥æ•°ç»„å…ƒç´ ä¸ºæŒ‡é’ˆç±»å‹ï¼Œåˆ™æ ¹æ®æŒ‡é’ˆå ç”¨ç©ºé—´ç»“åˆå…ƒç´ ä¸ªæ•°è®¡ç®—ç©ºé—´å¤§å°\n    // å¹¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´\n    case et.size == goarch.PtrSize:\n        lenmem = uintptr(old.len) * goarch.PtrSize\n        newlenmem = uintptr(cap) * goarch.PtrSize\n        capmem = roundupsize(uintptr(newcap) * goarch.PtrSize)\n        overflow = uintptr(newcap) &gt; maxAlloc/goarch.PtrSize\n        newcap = int(capmem / goarch.PtrSize)\n    // å€˜è‹¥å…ƒç´ å¤§å°ä¸º 2 çš„æŒ‡æ•°ï¼Œåˆ™ç›´æ¥é€šè¿‡ä½è¿ç®—è¿›è¡Œç©ºé—´å¤§å°çš„è®¡ç®—   \n    case isPowerOfTwo(et.size):\n        var shift uintptr\n        if goarch.PtrSize == 8 {\n            // Mask shift for better code generation.\n            shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63\n        } else {\n            shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31\n        }\n        lenmem = uintptr(old.len) &lt;&lt; shift\n        newlenmem = uintptr(cap) &lt;&lt; shift\n        capmem = roundupsize(uintptr(newcap) &lt;&lt; shift)\n        overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)\n        newcap = int(capmem &gt;&gt; shift)\n    // å…œåº•åˆ†æ”¯ï¼šæ ¹æ®å…ƒç´ å¤§å°ä¹˜ä»¥å…ƒç´ ä¸ªæ•°\n    // å†é’ˆå¯¹ span class è¿›è¡Œå–æ•´     \n    default:\n        lenmem = uintptr(old.len) * et.size\n        newlenmem = uintptr(cap) * et.size\n        capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))\n        capmem = roundupsize(capmem)\n        newcap = int(capmem / et.size)\n    }\n \n \n \n \n    // è¿›è¡Œå®é™…çš„åˆ‡ç‰‡åˆå§‹åŒ–æ“ä½œ\n    var p unsafe.Pointer\n    // éæŒ‡é’ˆç±»å‹\n    if et.ptrdata == 0 {\n        p = mallocgc(capmem, nil, false)\n        // ...\n    } else {\n        // æŒ‡é’ˆç±»å‹\n        p = mallocgc(capmem, et, true)\n        // ...\n    }\n    // å°†åˆ‡ç‰‡çš„å†…å®¹æ‹·è´åˆ°æ‰©å®¹åçš„ä½ç½® p \n    memmove(p, old.array, lenmem)\n    return slice{p, old.len, newcap}\n}\nåˆ‡ç‰‡çš„æˆªå–\n\nè¦æ³¨æ„è¿™é‡Œæ˜¯å·¦é—­å³å¼€,å› æ­¤[0:2]å–çš„æ˜¯ç¬¬0.1ä½,2å¹¶æ²¡æœ‰ç®—è¿›æ¥\n\n\n[:]=[0:len(s)]\n\n\n[:3]=[0:3]\n\n\n[4:]=[4:len(s)]\n\n\næœ¬è´¨ä¸Šæ˜¯å¼•ç”¨ä¼ é€’æ“ä½œ,å› æ­¤æ— è®ºæˆªå–å¤šå°‘æ¬¡,åº•å±‚éƒ½æ˜¯åŒä¸€å—å†…å­˜ç©ºé—´æ•°æ®.ä¸è¿‡æˆªå–ä¼šåˆ›å»ºå‡ºæ–°çš„slice headerå®ä¾‹\n\n\nå› ä¸ºå®é™…ä¸ŠæŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªåœ°å€åŒºé—´,å› æ­¤ä¿®æ”¹å…¶ä¸­ä¸€ä¸ªå…ƒç´ ä¼šå½±å“åˆ°å¦å¤–ä¸€ä¸ªæ•°ç»„çš„\n\n\nå¦‚æœè¦åˆ†å¼€æˆªå–çš„è¯å°±ä½¿ç”¨copyå‡½æ•°,ç›¸å½“äºæ‹·è´ä¸€ä¸ªå‰¯æœ¬,è¿™æ ·ä¿®æ”¹çš„è¯ä¸ä¼šå½±å“åˆ°æœ¬æ¥çš„slice\n\n\n\nå…ƒç´ åˆ é™¤\nä»åˆ‡ç‰‡ä¸­åˆ é™¤å…ƒç´ (åªå¯¹lenåšä¿®æ”¹)çš„å®ç°æ€è·¯ï¼Œæœ¬è´¨ä¸Šå’Œåˆ‡ç‰‡å†…å®¹æˆªå–çš„æ€è·¯æ˜¯ä¸€è‡´çš„.\n\nåˆ é™¤ slice ä¸­çš„é¦–ä¸ªå…ƒç´ ï¼Œåœ¨æ“ä½œä¸Šç­‰åŒäºä»åˆ‡ç‰‡ index = 1 å¼€å§‹å‘åè¿›è¡Œå†…å®¹æˆªå–\nåˆ é™¤ slice çš„å°¾éƒ¨å…ƒç´ ï¼Œåˆ™æ“ä½œç­‰ä»·äºæˆªå–åˆ‡ç‰‡å†…å®¹ï¼Œå¹¶å°†ç»ˆç‚¹è®¾ç½®åœ¨ len(s) - 1 çš„ä½ç½®\nåˆ é™¤ slice ä¸­é—´çš„æŸä¸ªå…ƒç´ ï¼Œæ“ä½œæ€è·¯åˆ™æ˜¯é‡‡ç”¨å†…å®¹æˆªå–åŠ ä¸Šå…ƒç´ è¿½åŠ çš„å¤åˆæ“ä½œï¼Œå¯ä»¥å…ˆæˆªå–å¾…åˆ é™¤å…ƒç´ çš„å·¦ä¾§éƒ¨åˆ†å†…å®¹ï¼Œç„¶ååœ¨æ­¤åŸºç¡€ä¸Šè¿½åŠ ä¸Šå¾…åˆ é™¤å…ƒç´ åä¾§éƒ¨åˆ†çš„å†…å®¹\næœ€åï¼Œå½“æˆ‘ä»¬éœ€è¦åˆ é™¤ slice ä¸­çš„æ‰€æœ‰å…ƒç´ æ—¶ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨åˆ‡ç‰‡å†…å®¹æˆªå–çš„æ“ä½œæ–¹å¼ï¼šs[:0]. è¿™æ ·æ“ä½œåï¼Œslice header ä¸­çš„æŒ‡é’ˆ array ä»æŒ‡å‘åŸå¤„ï¼Œä½†æ˜¯é€»è¾‘æ„ä¹‰ä¸Šå…¶é•¿åº¦ len å·²ç»ç­‰äº 0ï¼Œè€Œå®¹é‡ cap åˆ™ä»ä¿ç•™ä¸ºåŸå€¼.\n\nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    // [1,2,3,4]\n    s = s[1:]\n}\n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    // [0,1,2,3]\n    s = s[0:len(s)-1]\n}\n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    // åˆ é™¤ index = 2 çš„å…ƒç´ \n    s = append(s[:2],s[3:]...)//\n    // s: [0,1,3,4], len: 4, cap: 5\n    t.Logf(&quot;s: %v, len: %d, cap: %d&quot;, s, len(s), cap(s))\n}\n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    s = s[:0]\n    // s: [], len: 0, cap: 5\n    t.Logf(&quot;s: %v, len: %d, cap: %d&quot;, s, len(s), cap(s))\n}\nâ€¦:\n\nåœ¨å‡½æ•°å®šä¹‰ä¸­,func myFunc(args ...int)ï¼Œè¿™é‡Œ ... æ„å‘³ç€ myFunc æ˜¯ä¸€ä¸ªå¯å˜å‚æ•°å‡½æ•°ã€‚å®ƒå¯ä»¥æ¥å—ä»»æ„æ•°é‡çš„ int ä½œä¸ºå‚æ•°ï¼ˆ0ä¸ªã€1ä¸ªæˆ–å¤šä¸ªï¼‰ã€‚\nåœ¨å‡½æ•°è°ƒç”¨ä¸­ ï¼šappend(s1, s2...)ï¼Œè¿™é‡Œçš„ ... æ„æ€æ˜¯â€œå°†è¿™ä¸ªåˆ‡ç‰‡ (slice) æ‹†åŒ…/è§£å¼€ (unpack/expand)â€ã€‚\n\nå› ä¸ºappendå¹¶ä¸æ¥å—ä¸€ä¸ªsliceä½œä¸ºç¬¬äºŒä¸ªå‚æ•°,äºæ˜¯æˆ‘ä»¬ç”¨â€¦å°†sliceæ‹†åˆ†ä¸ºå•ç‹¬å…ƒç´ \n\n\n\nåˆ‡ç‰‡æ‹·è´\nåŒ…æ‹¬ç®€å•æ‹·è´å’Œå®Œæ•´æ‹·è´ä¸¤ç§\n\nç®€å•æ‹·è´\n\nåªè¦å¯¹åˆ‡ç‰‡çš„å­—é¢é‡è¿›è¡Œèµ‹å€¼ä¼ é€’.è¿™æ ·ç›¸å½“äºåˆ›å»ºå‡ºäº†ä¸€ä¸ªæ–°çš„ slice header å®ä¾‹ï¼Œä½†æ˜¯å…¶ä¸­çš„æŒ‡é’ˆ arrayã€å®¹é‡ cap å’Œé•¿åº¦ len ä»å’Œè€çš„ slice header å®ä¾‹ç›¸åŒ..\nå¯¹åˆ‡ç‰‡è¿›è¡Œ%pæ‰“å°åœ°å€,æ‰“å°å‡ºæ¥çš„ä¸æ˜¯slice headerçš„åœ°å€,è€Œæ˜¯å†…éƒ¨arrayå­—æ®µæŒ‡å‘çš„æ•°ç»„åœ°å€\nåˆ‡ç‰‡çš„æˆªå–æ“ä½œä¹Ÿå±äºæ˜¯ç®€å•æ‹·è´ï¼Œs å’Œ s1 ä¼šä½¿ç”¨åŒä¸€ç‰‡å†…å­˜ç©ºé—´ï¼Œåªä¸è¿‡åœ°å€èµ·ç‚¹ä½ç½®åç§»äº†ä¸€ä¸ªå…ƒç´ çš„é•¿åº¦. s1 å’Œ s çš„åœ°å€ï¼Œåˆšå¥½ç›¸å·® 8 ä¸ª byte.\n\n\nå®Œæ•´æ‹·è´\n\næŒ‡çš„æ˜¯ä¼šåˆ›å»ºå‡ºä¸€ä¸ªå’Œ slice å®¹é‡å¤§å°ç›¸ç­‰çš„ç‹¬ç«‹çš„å†…å­˜åŒºåŸŸï¼Œå¹¶å°†åŸ slice ä¸­çš„å…ƒç´ ä¸€ä¸€æ‹·è´åˆ°æ–°ç©ºé—´ä¸­.åœ¨å®ç°ä¸Šï¼Œslice çš„å®Œæ•´å¤åˆ¶å¯ä»¥è°ƒç”¨ç³»ç»Ÿæ–¹æ³• copyï¼Œé€šè¿‡æ—¥å¿—æ‰“å°çš„æ–¹å¼å¯ä»¥çœ‹åˆ°ï¼Œs å’Œ s1 çš„åœ°å€æ˜¯ç›¸äº’ç‹¬ç«‹çš„.å› æ­¤å¯¹åº”çš„æ•°ç»„åœ°å€ä¹Ÿæ˜¯å…¨æ–°çš„\n\n\n\né—®é¢˜è¾¨æ\nfunc Test_slice(t *testing.T){\n    s := make([]int,10)  \n    s = append(s,10)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s,len(s),cap(s))\n}\n//ç»“æœ:s: [0 0 0 0 0 0 0 0 0 0 10], len of s: 11, cap of s: 20\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,0,10)  \n    s = append(s,10)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s,len(s),cap(s))\n}\n//ç»“æœ:s: [10], len of s: 1, cap of s: 10\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,11)  \n    s = append(s,10)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s,len(s),cap(s))\n}\n//ç»“æœ:s: [0 0 0 0 0 0 0 0 0 0 10], len of s: 11, cap of s: 11\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    t.Logf(&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;,s1,len(s1),cap(s1))\n}\n//ç»“æœ:s1=[0 0] len=2 cap=4\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:9]\n    t.Logf(&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;,s1,len(s1),cap(s1))\n}\n//ç»“æœ:s1=[0] len:1 cap:4\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    s1[0] = -1\n    t.Logf(&quot;s: %v&quot;,s)\n}\n//ç»“æœ:s: [0 0 0 0 0 0 0 0 -1 0]\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    v := s[10]\n    // æ±‚é—®ï¼Œæ­¤æ—¶æ•°ç»„è®¿é—®æ˜¯å¦ä¼šè¶Šç•Œ\n}\n//ä¼šè¶Šç•Œ,å› ä¸ºlen=10 æ˜¯0-9çš„ç´¢å¼•ä¸Šæœ‰å€¼\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    s1 = append(s1,[]int{10,11,12}...)\n    v := s[10]\n    // ...\n    // æ±‚é—®ï¼Œæ­¤æ—¶æ•°ç»„è®¿é—®æ˜¯å¦ä¼šè¶Šç•Œ\n}\n//ç”±äº s é¢„ç•™çš„ç©ºé—´ä¸è¶³ï¼Œs1 ä¼šå‘ç”Ÿæ‰©å®¹,æ‰©å®¹åä¼šè¿”å›æ‹·è´åçš„æ–°åˆ‡ç‰‡,è¿™é‡Œçš„æ‹·è´æ˜¯å®Œæ•´æ‹·è´,æ„å‘³ç€ä¿®æ”¹ s1 ä¸å†ä¼šå½±å“åˆ° s\n//Â s ç»§ç»­ç»´æŒåŸæœ¬çš„é•¿åº¦å€¼ 10 å’Œå®¹é‡å€¼ 12ï¼Œå› æ­¤è®¿é—® s[10] ä¼španic\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    changeSlice(s1)\n    t.Logf(&quot;s: %v&quot;,s)\n}\n \n \nfunc changeSlice(s1 []int){\n  s1[0] = -1\n}\n//ç»“æœ:s=[00000000-10  ]s1=[-10  ]\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    changeSlice(s1)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s, len(s), cap(s))\n    t.Logf(&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;,s1, len(s1), cap(s1))\n}\n \n \nfunc changeSlice(s1 []int){\n  s1 = append(s1, 10)\n}\n//ç»“æœ:s=[0000000000  ]ä¸å˜ s1ä¹Ÿä¸å˜\n//åœ¨å±€éƒ¨æ–¹æ³• changeSlice ä¸­ï¼Œè™½ç„¶å¯¹ s1 è¿›è¡Œäº† append æ“ä½œï¼Œä½†è¿™è¿™ä¼šåœ¨å±€éƒ¨æ–¹æ³•ä¸­è¿™ä¸ªç‹¬ç«‹çš„ slice header ä¸­ç”Ÿæ•ˆï¼Œä¸ä¼šå½±å“åˆ°åŸæ–¹æ³• Test_slice å½“ä¸­çš„ s å’Œ s1 çš„**é•¿åº¦å’Œå®¹é‡**.    \n \n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    s = append(s[:2],s[3:]...)\n    t.Logf(&quot;s: %v, len: %d, cap: %d&quot;, s, len(s), cap(s))\n    v := s[4] \n    // æ˜¯å¦ä¼šæ•°ç»„è®¿é—®è¶Šç•Œ\n}\n//[0,1,3,4] ä¼š.\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,512)  \n    s = append(s,1)\n    t.Logf(&quot;len of s: %d, cap of s: %d&quot;,len(s),cap(s))\n}\n//ç»“æœ:len=513 cap: æ ¹æ®ä¸åˆ°ä¸¤å€ä¸”&gt;256çš„è®¡ç®—æ–¹å¼(n += (n+3*256)/4) å¯ä»¥è®¡ç®—åˆ°832, ç„¶åæ ¹æ®mspanå‘ä¸Šè¡¥é½çš„æ³•åˆ™,å¾—åˆ°848\nå…¶ä»–\nslice ä¸æ˜¯å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„,æ²¡æœ‰å¯¹å¹¶å‘è¯»å†™çš„ä¿æŠ¤æœºåˆ¶.\nå‚è€ƒèµ„æ–™\nä½ çœŸçš„äº†è§£goè¯­è¨€ä¸­çš„åˆ‡ç‰‡å—ï¼Ÿâ€”å°å¾å…ˆç”Ÿçš„ç¼–ç¨‹ä¸–ç•Œ"},"ç”Ÿæ´»æ‚è°ˆ/test":{"slug":"ç”Ÿæ´»æ‚è°ˆ/test","filePath":"ç”Ÿæ´»æ‚è°ˆ/test.md","title":"test","links":[],"tags":[],"content":""},"è¯¾ç¨‹ç¬”è®°/æ“ä½œç³»ç»Ÿ/test":{"slug":"è¯¾ç¨‹ç¬”è®°/æ“ä½œç³»ç»Ÿ/test","filePath":"è¯¾ç¨‹ç¬”è®°/æ“ä½œç³»ç»Ÿ/test.md","title":"test","links":[],"tags":[],"content":""}}