{"index":{"slug":"index","filePath":"index.md","title":"🏠 首页","links":["about"],"tags":[],"content":"欢迎来到 ING wiki！\n持续建设中…\n📂 导航\n\n关于我\n\n📝 最近更新\n\n这里可以写一些最近的想法或者置顶的内容。\n"},"工具使用/Obsidian插件":{"slug":"工具使用/Obsidian插件","filePath":"工具使用/Obsidian插件.md","title":"Obsidian插件","links":[],"tags":[],"content":"templater\n可以把Templates文件夹下的笔记作为模板,左侧功能栏点击即可套用到其他笔记上.不会影响已写的内容.\nConsistent Attachments and Links\n右键某个文件夹,可以从整个仓库收集属于该文件夹下笔记的图片,并放到该文件夹下的attachments文件夹中.\n\n首先要在obsidian设置-文件与链接-附件默认存放路径,确定好附件存放方式是在文件夹下的attachments文件夹.\n使用时,比如先移动了一个笔记,然后右键笔记所属文件夹即可选择collect attachments.[注意不要对附件文件夹做任何删除操作,这个移动是附件本体进行移动,不是副本移动]\n\nGit\n好用,可以把整个obsidian仓库托管到git然后设置每两小时提交一次(如果有修改的话).我之前琢磨附件插件的时候把附件删没了全靠git找回来(当然也可以去回收站找)\nShell Commands\n可以编写终端指令.使用例:\n\n编写了一个指令,每次Obsidian打开的时候会自动进入我的博客本地仓库进行一次发布.\n"},"工具使用/博客搭建":{"slug":"工具使用/博客搭建","filePath":"工具使用/博客搭建.md","title":"博客搭建","links":[],"tags":[],"content":"基于Obsidian和Quartz4.流程:\n\n将quartz4仓库克隆到本地.然后将content文件夹重定向到本地obsidian仓库的public文件夹.这样两边的内容会进行一个同步.\n为本地quartz仓库配置私钥和公钥.私钥链接到github私有仓库.公钥连接到github公有仓库.这样只有静态产物会deploy到公有仓库,将公有仓库名字设置为username.github.io即可.\n在obsidian中的Public文件夹下书写笔记,然后在quartz4本地仓库进行提交.这样之后私有仓库[博客源码]会更新.公有仓库[静态产物]也会更新,最终体现在博客网页上.\n\ntips\n\nquartz.config.ts-&gt;plugins -&gt; transformers\n加上一行Plugin.HardLineBreaks(),,就会调用remark-breaks 这个库,将所有换行强制渲染成&lt;br&gt;,否则笔记里面的本来的换行选然后会变成空格.[只有两次回车/两个空格一次回车会被渲染成换行但是太麻烦了所以]\n"},"技术积累/Golang/04-slice切片动态数组类型":{"slug":"技术积累/Golang/04-slice切片动态数组类型","filePath":"技术积累/Golang/04 slice切片动态数组类型.md","title":"04 slice切片动态数组类型","links":[],"tags":[],"content":"tips\n// 原写法  s := []byte{} 得到的不是nil切片\n// 替代写法 var s []byte 得到的是nil切片,但是可以照常append go自己会处理\n也可以s := make([]byte, 0)\n//注意切片是左闭右开,\n固定长度数组array\n但是在go中不等同于其他语言数组的地位,可以说slice才是go语言的数组.\n\n根据索引初始化 注意默认值是0\n查看数组的数据类型：长度变成了类型的一部分,因此存在两个问题\n\n因此传参的时候也要区分不同长度的数组了\n而且仍然是一个值传递（把本来的数组拷贝给形参，所以还是会有之前那个内存和地址的问题，所以不能进行改动）\n\n\n所以说要传参的话最好还是写动态数组,也可以使用切片操作符 [:] 你可以把数组“切”一下,这里是创建一个引用 不是copy,相当于传了地址\n\nrange关键字\n根据遍历不同集合返回不同值。\n\n数组或切片\n\n返回两个值  当前元素所在索引和当前元素值本身如果不关心某个返回值的话可以把它设置成匿名\n\n\n\n动态数组:切片 slice\n数据结构\n连续的内存,本身只包含三个信息(可以在runtime包下查询)\ntype slice struct {\n    // 指向起点的地址\n    array unsafe.Pointer\n    // 切片长度\n    len   int\n    // 切片容量\n    cap   int\n}\n\n指针 第一个元素的内存地址\n长度 当前存放的元素个数  访问切片是否合法\n容量 总共能装多少个元素(提前分配的空间元素个数),cap永远大于等于len 考虑性能优化\n\n\n索引时只需要计算目标地址 = 起始地址 + ( 索引 x 每个元素的大小 ),因此时间复杂度是O(1)\n\n特征\n\n传递时表面上是进行slice header的值传递,但因为内部存放的是unsafe.Pointer地址,因此实际上相当于引用传递,可以直接进行传递并在函数中进行值修改.[go语言中没有真正的引用传递,基本都是这样的伪引用传递].\n\n因此len和cap在函数中被修改是不会反映到底层数据结构的\n\n\n括号里面是空的，表示动态。可以看到类型也是动态数组类型\n\nslice切片的四种声明方式/初始化\n\n声明但不进行初始化\n\n判断一个slice是否为空nil [没有空间,而全0不算空]\n空slice不能够进行赋值,但是可以进行append(相当于一个一个开辟空间)\n\n\n\nvar s []init\n \n//判断一个slice是否为0\nif  slice1 == nil{\n\tfmt.println(&quot;是一个空切片&quot;)\n\t}else{\n\tfmt.println(&quot;不是一个空切片&quot;)}\nelse和前后两个括号需要在同一行否则会报语法错\n\n基于make进行初始化\n\n只初始化len而不初始化cap.\n\n此时会将len和cap同时默认设置为len的值.因为如果len&gt;cap会初始化失败.\n切片的长度一旦被指定了，就代表对应位置已经被分配了元素，设置的会是对应元素类型下的零值.\n\n\n分别指定len和cap\n\n在index【len,cap)的区域无法被访问,因为逻辑上不存在元素,访问会被报错.\n\n\n\n\n\ns := make([]int,8)\ns := make([]int,8,16)\n\n%v 可以打印数组内详细数据\n\n\n初始化连带赋值\n\n会将len和cap同时设为3并且完成赋值\n\n\n\n  s := []int{2,3,4}\n初始化源码\nfunc makeslice(et *_type, len, cap int) unsafe.Pointer {\n    // 根据 cap 结合每个元素的大小，计算出消耗的总容量\n    mem, overflow := math.MulUintptr(et.size, uintptr(cap))\n    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {\n        // 倘若容量超限，len 取负值或者 len 超过 cap，直接 panic\n        mem, overflow := math.MulUintptr(et.size, uintptr(len))\n        if overflow || mem &gt; maxAlloc || len &lt; 0 {\n            panicmakeslicelen()\n        }\n        panicmakeslicecap()\n    }\n    // 走 mallocgc 进行内存分配以及切片初始化,以及回收\n    return mallocgc(mem, et, true)\n}\n追加与截取\n切片的追加\n通过 append 操作，可以在 slice 的末尾，额外新增一个元素.\n\n这里的末尾指的是针对 slice 的长度 len 而言.实际上截取的话,从起点开始的容量会保留,详见辨析5\n这个过程中倘若发现 slice 的剩余cap已经不足了，则会对 slice 进行扩容.动态开辟相当于本来cap的容量\n\n\n在创建 slice 时，如果能够预估到其未来所需的容量空间,应该提前分配好对应容量，避免在运行过程中频繁触发扩容操作，这样会对性能产生不利的影响.\n\n\n实例1\n倘若希望使用 append 操作完成 slice 赋值，则应该在初始化 slice 时，给其设置不同的长度 len 和容量 cap 值，cap 和 len 之间的差值就是预留出来用于 append 操作的空间. 具体代码如下：\nfunc Test_slice(t *testing.T){\n    s := make([]int,0,5)\n    for i := 0; i &lt; 5; i++{\n       s = append(s, i)//追加的对象数组,以及追加的数据\n    }\n    // 结果为：\n    // s: [0,1,2,3,4]\n}\n实例2\n我们将 slice 的长度和容量都设置为 5,然后通过遍历 slice 的方式进行执行位置元素的赋值（不使用 append 操作）：\nfunc Test_slice(t *testing.T){\n    s := make([]int,5)\n    for i := 0; i &lt; 5; i++{\n       s[i] = i\n    }\n    // 结果为：\n    // s: [0,1,2,3,4]\n}\n扩容\n当len与cap相等时,下一次append操作就会进行一次扩容\n    // len:4, cap: 4\n    s := []int{2,3,4,5}\n    // len:5, cap: 8    len=原来的长度+1,cap=原来的cap*2\n    s = append(s,6)\n\n\n预期容量:\n\n如果只追加一个元素,预期容量就是原本的容量+1,类似的.\n\n老容量&lt;256 则扩容为原来的两倍\n老容量&gt;256 那么就进入一个循环,按照特殊方式扩容直到大于等于预期容量.如果在这个循环中数值太大了以至于越界,那么就直接取预期新容量为最终值\n\n\n如果预期元素是比如一个切片,那么预期容量就可能会超出原容量的两倍.\n\n\n根据数据类型推算出实际需要的内存大小,然后mallocgc中还要对内存分配单元mspan的等级制度,推算得到实际需要申请的内存空间大小(向上取整)\n\nmheap是go管理的所有内存之和\nmspan就是标准大小地块,有不同大小等级共程序申请使用.\n\n\n调用 mallocgc，对新切片进行内存初始化\n调用 memmove 方法，将老切片中的内容拷贝到新切片中\n返回扩容后的新切片【扩容后会变成新的地址】\n源码:\n\nfunc growslice(et *_type, old slice, cap int) slice {\n    //... \n    if cap &lt; old.cap {\n        panic(errorString(&quot;growslice: cap out of range&quot;))\n    }\n \n \n    if et.size == 0 {\n        // 倘若元素大小为 0，则无需分配空间直接返回\n        return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}\n    }\n \n \n    // 计算扩容后数组的容量\n    newcap := old.cap\n    // 取原容量两倍的容量数值\n    doublecap := newcap + newcap\n    // 倘若新的容量大于原容量的两倍，直接取新容量作为数组扩容后的容量\n    if cap &gt; doublecap {\n        newcap = cap\n    } else {\n        const threshold = 256\n        // 倘若原容量小于 256，则扩容后新容量为原容量的两倍\n        if old.cap &lt; threshold {\n            newcap = doublecap\n        } else {\n            // 在原容量的基础上，对原容量 * 5/4 并且加上 192\n            // 循环执行上述操作，直到扩容后的容量已经大于等于预期的新容量为止\n            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {             \n                newcap += (newcap + 3*threshold) / 4\n            }\n            // 倘若数值越界了，则取预期的新容量 cap 封顶\n            if newcap &lt;= 0 {\n                newcap = cap\n            }\n        }\n    }\n \n \n    var overflow bool\n    var lenmem, newlenmem, capmem uintptr\n    // 基于容量，确定新数组容器所需要的内存空间大小 capmem\n    switch {\n    // 倘若数组元素的大小为 1，则新容量大小为 1 * newcap.\n    // 同时会针对 span class 进行取整\n    case et.size == 1:\n        lenmem = uintptr(old.len)\n        newlenmem = uintptr(cap)\n        capmem = roundupsize(uintptr(newcap))\n        overflow = uintptr(newcap) &gt; maxAlloc\n        newcap = int(capmem)\n    // 倘若数组元素为指针类型，则根据指针占用空间结合元素个数计算空间大小\n    // 并会针对 span class 进行取整\n    case et.size == goarch.PtrSize:\n        lenmem = uintptr(old.len) * goarch.PtrSize\n        newlenmem = uintptr(cap) * goarch.PtrSize\n        capmem = roundupsize(uintptr(newcap) * goarch.PtrSize)\n        overflow = uintptr(newcap) &gt; maxAlloc/goarch.PtrSize\n        newcap = int(capmem / goarch.PtrSize)\n    // 倘若元素大小为 2 的指数，则直接通过位运算进行空间大小的计算   \n    case isPowerOfTwo(et.size):\n        var shift uintptr\n        if goarch.PtrSize == 8 {\n            // Mask shift for better code generation.\n            shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63\n        } else {\n            shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31\n        }\n        lenmem = uintptr(old.len) &lt;&lt; shift\n        newlenmem = uintptr(cap) &lt;&lt; shift\n        capmem = roundupsize(uintptr(newcap) &lt;&lt; shift)\n        overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)\n        newcap = int(capmem &gt;&gt; shift)\n    // 兜底分支：根据元素大小乘以元素个数\n    // 再针对 span class 进行取整     \n    default:\n        lenmem = uintptr(old.len) * et.size\n        newlenmem = uintptr(cap) * et.size\n        capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))\n        capmem = roundupsize(capmem)\n        newcap = int(capmem / et.size)\n    }\n \n \n \n \n    // 进行实际的切片初始化操作\n    var p unsafe.Pointer\n    // 非指针类型\n    if et.ptrdata == 0 {\n        p = mallocgc(capmem, nil, false)\n        // ...\n    } else {\n        // 指针类型\n        p = mallocgc(capmem, et, true)\n        // ...\n    }\n    // 将切片的内容拷贝到扩容后的位置 p \n    memmove(p, old.array, lenmem)\n    return slice{p, old.len, newcap}\n}\n切片的截取\n\n要注意这里是左闭右开,因此[0:2]取的是第0.1位,2并没有算进来\n\n\n[:]=[0:len(s)]\n\n\n[:3]=[0:3]\n\n\n[4:]=[4:len(s)]\n\n\n本质上是引用传递操作,因此无论截取多少次,底层都是同一块内存空间数据.不过截取会创建出新的slice header实例\n\n\n因为实际上指向的是同一个地址区间,因此修改其中一个元素会影响到另外一个数组的\n\n\n如果要分开截取的话就使用copy函数,相当于拷贝一个副本,这样修改的话不会影响到本来的slice\n\n\n\n元素删除\n从切片中删除元素(只对len做修改)的实现思路，本质上和切片内容截取的思路是一致的.\n\n删除 slice 中的首个元素，在操作上等同于从切片 index = 1 开始向后进行内容截取\n删除 slice 的尾部元素，则操作等价于截取切片内容，并将终点设置在 len(s) - 1 的位置\n删除 slice 中间的某个元素，操作思路则是采用内容截取加上元素追加的复合操作，可以先截取待删除元素的左侧部分内容，然后在此基础上追加上待删除元素后侧部分的内容\n最后，当我们需要删除 slice 中的所有元素时，也可以采用切片内容截取的操作方式：s[:0]. 这样操作后，slice header 中的指针 array 仍指向原处，但是逻辑意义上其长度 len 已经等于 0，而容量 cap 则仍保留为原值.\n\nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    // [1,2,3,4]\n    s = s[1:]\n}\n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    // [0,1,2,3]\n    s = s[0:len(s)-1]\n}\n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    // 删除 index = 2 的元素\n    s = append(s[:2],s[3:]...)//\n    // s: [0,1,3,4], len: 4, cap: 5\n    t.Logf(&quot;s: %v, len: %d, cap: %d&quot;, s, len(s), cap(s))\n}\n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    s = s[:0]\n    // s: [], len: 0, cap: 5\n    t.Logf(&quot;s: %v, len: %d, cap: %d&quot;, s, len(s), cap(s))\n}\n…:\n\n在函数定义中,func myFunc(args ...int)，这里 ... 意味着 myFunc 是一个可变参数函数。它可以接受任意数量的 int 作为参数（0个、1个或多个）。\n在函数调用中 ：append(s1, s2...)，这里的 ... 意思是“将这个切片 (slice) 拆包/解开 (unpack/expand)”。\n\n因为append并不接受一个slice作为第二个参数,于是我们用…将slice拆分为单独元素\n\n\n\n切片拷贝\n包括简单拷贝和完整拷贝两种\n\n简单拷贝\n\n只要对切片的字面量进行赋值传递.这样相当于创建出了一个新的 slice header 实例，但是其中的指针 array、容量 cap 和长度 len 仍和老的 slice header 实例相同..\n对切片进行%p打印地址,打印出来的不是slice header的地址,而是内部array字段指向的数组地址\n切片的截取操作也属于是简单拷贝，s 和 s1 会使用同一片内存空间，只不过地址起点位置偏移了一个元素的长度. s1 和 s 的地址，刚好相差 8 个 byte.\n\n\n完整拷贝\n\n指的是会创建出一个和 slice 容量大小相等的独立的内存区域，并将原 slice 中的元素一一拷贝到新空间中.在实现上，slice 的完整复制可以调用系统方法 copy，通过日志打印的方式可以看到，s 和 s1 的地址是相互独立的.因此对应的数组地址也是全新的\n\n\n\n问题辨析\nfunc Test_slice(t *testing.T){\n    s := make([]int,10)  \n    s = append(s,10)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s,len(s),cap(s))\n}\n//结果:s: [0 0 0 0 0 0 0 0 0 0 10], len of s: 11, cap of s: 20\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,0,10)  \n    s = append(s,10)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s,len(s),cap(s))\n}\n//结果:s: [10], len of s: 1, cap of s: 10\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,11)  \n    s = append(s,10)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s,len(s),cap(s))\n}\n//结果:s: [0 0 0 0 0 0 0 0 0 0 10], len of s: 11, cap of s: 11\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    t.Logf(&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;,s1,len(s1),cap(s1))\n}\n//结果:s1=[0 0] len=2 cap=4\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:9]\n    t.Logf(&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;,s1,len(s1),cap(s1))\n}\n//结果:s1=[0] len:1 cap:4\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    s1[0] = -1\n    t.Logf(&quot;s: %v&quot;,s)\n}\n//结果:s: [0 0 0 0 0 0 0 0 -1 0]\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    v := s[10]\n    // 求问，此时数组访问是否会越界\n}\n//会越界,因为len=10 是0-9的索引上有值\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    s1 = append(s1,[]int{10,11,12}...)\n    v := s[10]\n    // ...\n    // 求问，此时数组访问是否会越界\n}\n//由于 s 预留的空间不足，s1 会发生扩容,扩容后会返回拷贝后的新切片,这里的拷贝是完整拷贝,意味着修改 s1 不再会影响到 s\n// s 继续维持原本的长度值 10 和容量值 12，因此访问 s[10] 会panic\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    changeSlice(s1)\n    t.Logf(&quot;s: %v&quot;,s)\n}\n \n \nfunc changeSlice(s1 []int){\n  s1[0] = -1\n}\n//结果:s=[00000000-10  ]s1=[-10  ]\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,10,12)  \n    s1 := s[8:]\n    changeSlice(s1)\n    t.Logf(&quot;s: %v, len of s: %d, cap of s: %d&quot;,s, len(s), cap(s))\n    t.Logf(&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;,s1, len(s1), cap(s1))\n}\n \n \nfunc changeSlice(s1 []int){\n  s1 = append(s1, 10)\n}\n//结果:s=[0000000000  ]不变 s1也不变\n//在局部方法 changeSlice 中，虽然对 s1 进行了 append 操作，但这这会在局部方法中这个独立的 slice header 中生效，不会影响到原方法 Test_slice 当中的 s 和 s1 的**长度和容量**.    \n \n \nfunc Test_slice(t *testing.T){\n    s := []int{0,1,2,3,4}\n    s = append(s[:2],s[3:]...)\n    t.Logf(&quot;s: %v, len: %d, cap: %d&quot;, s, len(s), cap(s))\n    v := s[4] \n    // 是否会数组访问越界\n}\n//[0,1,3,4] 会.\n \n \nfunc Test_slice(t *testing.T){\n    s := make([]int,512)  \n    s = append(s,1)\n    t.Logf(&quot;len of s: %d, cap of s: %d&quot;,len(s),cap(s))\n}\n//结果:len=513 cap: 根据不到两倍且&gt;256的计算方式(n += (n+3*256)/4) 可以计算到832, 然后根据mspan向上补齐的法则,得到848\n其他\nslice 不是并发安全的数据结构,没有对并发读写的保护机制.\n参考资料\n你真的了解go语言中的切片吗？—小徐先生的编程世界"}}