<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>ING wiki</title>
      <link>https://im0x0ing.github.io</link>
      <description>Last 10 notes on ING wiki</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>strings</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E5%BA%93/strings</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E5%BA%93/strings</guid>
    <description><![CDATA[ strings.Builder 常用于在循环中对字符串进行增加的操作.builder就相当于一个缓冲区,在最后才生成最终的字符串. ]]></description>
    <pubDate>Mon, 08 Dec 2025 14:37:00 GMT</pubDate>
  </item><item>
    <title>fmt</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E5%BA%93/fmt</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E5%BA%93/fmt</guid>
    <description><![CDATA[ fmt.Print(&quot;Hello&quot;)//不换行原样输出 fmt.Println(&quot;a&quot;,&quot;b&quot;)//自动换行且参数之间自动加空格 fmt.Printf(&quot;我是%s,%d岁&quot;, name, age )//格式化输出,不换行 fmt.Scanln(&amp;n)//读取到的数据放入到这个地址中. ]]></description>
    <pubDate>Mon, 08 Dec 2025 14:36:00 GMT</pubDate>
  </item><item>
    <title>移动匹配</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%A7%BB%E5%8A%A8%E5%8C%B9%E9%85%8D</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%A7%BB%E5%8A%A8%E5%8C%B9%E9%85%8D</guid>
    <description><![CDATA[  ]]></description>
    <pubDate>Mon, 08 Dec 2025 14:36:00 GMT</pubDate>
  </item><item>
    <title>3. 无重复字符的最长子串</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2</guid>
    <description><![CDATA[ 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度 小记 滑动窗口思想 重复字符:记录频率 Transclude of 字符串处理#range与下标 代码 func lengthOfLongestSubstring(s string) int { //不含有重复字符:一个数组来记录字符出现的频率,.如果新进来的这个数=2了,就缩小左边直到这个数前面那个重复的数出去,2-1=1.确保整个数组内没有重复元素的时候可以记录最大值ans. ]]></description>
    <pubDate>Mon, 08 Dec 2025 14:31:00 GMT</pubDate>
  </item><item>
    <title>02 Instructions</title>
    <link>https://im0x0ing.github.io/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/02-Instructions</link>
    <guid>https://im0x0ing.github.io/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/02-Instructions</guid>
    <description><![CDATA[ DECK: CS::CO summary 寄存器 registers flashcard RISC-V architecture 提供 32 个数据寄存器，分别命名为 x0 ~ x31 ，每个寄存器的大小是 64 位。 x0 的值恒为 0 Preserved on call 意为是否保证调用前后这些寄存器的值不变。 也提供一系列浮点数寄存器 f0 ~ f31。 之所以寄存器的个数不多，是因为过多的寄存器会增加电子信号的传播距离，从而导致时钟周期的延长。 将不常用的（或之后用到的）变量存入内存的过程被称为溢出寄存器 (Spilling Register) 寄存器存储空间小，内存存储空间大 因此小... ]]></description>
    <pubDate>Mon, 08 Dec 2025 14:19:00 GMT</pubDate>
  </item><item>
    <title>5. 最长回文子串</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/5.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/5.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2</guid>
    <description><![CDATA[ 给你一个字符串 s，找到 s 中最长的 回文 子串。 小记 关键是枚举回文子串的中心。 然后从该中心触发,分奇数和偶数两种情况讨论即可 在左右相等时,持续扩散,直到数组边界 代码 func longestPalindrome(s string) string { n:=len(s) ans:=0 resl:=-1 resr:=n for i,_:=range s{ l,r:=i,i for l&gt;=0&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r]{ ans=max(ans,r-l+1) if ans==r-l+1{ resl=l resr=r } l-- r++ ... ]]></description>
    <pubDate>Mon, 08 Dec 2025 11:45:00 GMT</pubDate>
  </item><item>
    <title>栈与队列</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97</guid>
    <description><![CDATA[  go 中没有名为Stack的容器, 一般直接用切片作为栈 stack是如何实现的？ 实现：[]int (或其他类型的切片)。 Push (入栈)：使用 append 函数。 Pop (出栈)：使用切片的截取操作 Top (取栈顶)：直接索引 len(s)-1。 // 这是一个 Go 语言实现栈的标准写法 stack := make([]int, 0) // Push stack = append(stack, 1) stack = append(stack, 2) // Top (获取栈顶元素) top := stack[len(stack)-1] // Pop (移除栈顶元素) stack... ]]></description>
    <pubDate>Mon, 08 Dec 2025 11:36:00 GMT</pubDate>
  </item><item>
    <title>对称匹配</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%AF%B9%E7%A7%B0%E5%8C%B9%E9%85%8D</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%AF%B9%E7%A7%B0%E5%8C%B9%E9%85%8D</guid>
    <description><![CDATA[ 由于栈结构的特殊性,非常适合做对称匹配类的题目 不匹配的三种情况 已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false 遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false 遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false 技巧: 计算字符串长度如果是奇数那么一定不true 在遇到左括号的时候把右括号入栈，那么下次遇到右括号就只需要比较当前元素和栈顶是否相等就可以了 func isValid(s string) bool { if len(s)%2 != 0 {... ]]></description>
    <pubDate>Mon, 08 Dec 2025 11:09:00 GMT</pubDate>
  </item><item>
    <title>字符串处理</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86</guid>
    <description><![CDATA[ rune与byte与string &#039;a&#039; (单引号)：字符（Go 里叫 rune，本质是整数 `int32 int32，有 32 位，最大能表示几十亿,会根据字符串里的元素自动匹配要表示什么.比如”an按”会解析出3个rune:a\n\按 &quot;a&quot; (双引号：字符串`string byte 只有 8 位，最大只能表示到 255。英文字符（ASCII）比如 &#039;a&#039; 是 97，能装下。但汉字 &#039;按&#039; 的编号是 25353，一般是3个byte。 Title ‘a’虽然被认为是rune,但是实际上属于无类型常量 (Untyp... ]]></description>
    <pubDate>Mon, 08 Dec 2025 10:55:00 GMT</pubDate>
  </item><item>
    <title>KMP算法</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/KMP%E7%AE%97%E6%B3%95</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/KMP%E7%AE%97%E6%B3%95</guid>
    <description><![CDATA[ 取了三位学者名字的首字母。所以叫做KMP 主要思想 当出现字符串不匹配时,可以知道一部分之前已经匹配的内容,可以利用这些信息,避免从头匹配. 原理 next数组 本质上即为前缀表prefixtable 用来回退.记录了模式串与主串不匹配的时候,模式串应该从哪里开始重新匹配. ]]></description>
    <pubDate>Mon, 08 Dec 2025 10:24:00 GMT</pubDate>
  </item>
    </channel>
  </rss>