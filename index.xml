<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>ING wiki</title>
      <link>https://im0x0ing.github.io</link>
      <description>Last 10 notes on ING wiki</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>04 slice切片动态数组类型</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/slice%E5%88%87%E7%89%87%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/slice%E5%88%87%E7%89%87%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B</guid>
    <description><![CDATA[ tips var s []byte 得到的是nil切片,但是可以照常append go自己会处理.适用于不知道长度的情况下 s:=make([]int,0,k) 知道长度的情况下,这种做法更优. ]]></description>
    <pubDate>Thu, 11 Dec 2025 21:02:00 GMT</pubDate>
  </item><item>
    <title>05 map</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05-map</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/Golang/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05-map</guid>
    <description><![CDATA[ （1）存储基于 key-value 对映射的模式； （2）基于 key 维度实现存储数据的去重； （3）读、写、删操作控制，时间复杂度 O(1). ]]></description>
    <pubDate>Thu, 11 Dec 2025 20:48:00 GMT</pubDate>
  </item><item>
    <title>560. 和为K的子数组</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/560.-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/560.-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84</guid>
    <description><![CDATA[ 给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的子数组的个数。 子数组是数组中元素的连续非空序列。 小记 使用n数之和的思想. ]]></description>
    <pubDate>Thu, 11 Dec 2025 20:42:00 GMT</pubDate>
  </item><item>
    <title>未命名</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/n%E6%95%B0%E4%B9%8B%E5%92%8C</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/n%E6%95%B0%E4%B9%8B%E5%92%8C</guid>
    <description><![CDATA[ 一个数组中不重复 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 保证数组有序.不有序就排一下序. ]]></description>
    <pubDate>Thu, 11 Dec 2025 20:33:00 GMT</pubDate>
  </item><item>
    <title>滑动窗口与前缀和</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C</guid>
    <description><![CDATA[ 变长滑动窗口 注意使用数组元素都是正数的性质 右指针往右移 \rightarrow 窗口内和一定变大。 左指针往右移 \rightarrow 窗口内和一定变小。 如果题目中出现负数,则无法使用滑动窗口 空间复杂度O(1) 前缀和 通常配合哈希表,通过数学差值计算解决问题,不依赖单调性(正负数均可) 需要额外空间存储前缀信息:静态预处理 定长滑动窗口 正负数均可. ]]></description>
    <pubDate>Thu, 11 Dec 2025 20:28:00 GMT</pubDate>
  </item><item>
    <title>二分查找</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE</guid>
    <description><![CDATA[  数组下标都是从0开始的。 数组内存空间的地址是连续的 数组的元素是不能删的，只能覆盖。 二分查找 搜索的区间是左闭右闭还是左闭右开还是全开 这个是一个原则,在后面的区间处理中要贯彻.区间是一个不变量 在区间为空后再进行返回,可以找第一个等于target的数的下标,泛用性更强. ]]></description>
    <pubDate>Thu, 11 Dec 2025 20:25:00 GMT</pubDate>
  </item><item>
    <title>递归</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%80%92%E5%BD%92</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%80%92%E5%BD%92</guid>
    <description><![CDATA[ 递归的实现 递归的实现就是： 每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中. ]]></description>
    <pubDate>Thu, 11 Dec 2025 15:56:00 GMT</pubDate>
  </item><item>
    <title>test</title>
    <link>https://im0x0ing.github.io/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/test</link>
    <guid>https://im0x0ing.github.io/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/test</guid>
    <description><![CDATA[  ]]></description>
    <pubDate>Thu, 11 Dec 2025 15:56:00 GMT</pubDate>
  </item><item>
    <title>动态规划-贪心算法</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95</guid>
    <description><![CDATA[ 贪心算法 贪心算法在每一步选择中，都采取在当前状态下最好、最优的选择（局部最优解）从而希望最终的结果也是全局最优的。 只有当问题具备“贪心选择性质”时（即局部最优确实能推导出全局最优）才能得到正确答案。否则，它只能得到一个“差不多”的解，而不是最优解。 动态规划 动态规划将一个复杂的问题分解成若干个重叠的子问题。通过解决子问题，并将结果记录下来（Memoization/填表）避免重复计算，最后推导出原问题的解。 核心在于“记表”，算过的东西绝对不算第二次。 动态规划思路 以70. ]]></description>
    <pubDate>Thu, 11 Dec 2025 15:55:00 GMT</pubDate>
  </item><item>
    <title>121. 买卖股票的最佳时机</title>
    <link>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/121.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA</link>
    <guid>https://im0x0ing.github.io/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/hot100%E9%A2%98%E8%A7%A3/121.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA</guid>
    <description><![CDATA[ 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 小记 维护两个关键变量: 记录从第一天到当前这一天为止,出现的最低价格(假设买入点) 顺手记住的,所以只需要遍历一遍即可. ]]></description>
    <pubDate>Thu, 11 Dec 2025 15:50:00 GMT</pubDate>
  </item>
    </channel>
  </rss>