<!DOCTYPE html>
<html lang="en" dir="ltr"><head><title>04 内存模型与分配机制</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto Sans SC:wght@400;700&amp;family=Noto Serif SC:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700;1,900&amp;family=JetBrains Mono:wght@400;600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="ING wiki"/><meta property="og:title" content="04 内存模型与分配机制"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="04 内存模型与分配机制"/><meta name="twitter:description" content="mcache: 每个p自己的缓存,各种规格的mspan都缓存一份.不需要锁 mcentral: 某种特定规格的mspan的集合,如果p自己的缓存使用完了,就到mcentral里获取.需要锁."/><meta property="og:description" content="mcache: 每个p自己的缓存,各种规格的mspan都缓存一份.不需要锁 mcentral: 某种特定规格的mspan的集合,如果p自己的缓存使用完了,就到mcentral里获取.需要锁."/><meta property="og:image:alt" content="mcache: 每个p自己的缓存,各种规格的mspan都缓存一份.不需要锁 mcentral: 某种特定规格的mspan的集合,如果p自己的缓存使用完了,就到mcentral里获取.需要锁."/><meta property="twitter:domain" content="im0x0ing.github.io"/><meta property="og:url" content="https://im0x0ing.github.io/技术积累/Golang/核心知识/04-内存模型与分配机制"/><meta property="twitter:url" content="https://im0x0ing.github.io/技术积累/Golang/核心知识/04-内存模型与分配机制"/><link rel="icon" href="../../../static/icon.png"/><meta name="description" content="mcache: 每个p自己的缓存,各种规格的mspan都缓存一份.不需要锁 mcentral: 某种特定规格的mspan的集合,如果p自己的缓存使用完了,就到mcentral里获取.需要锁."/><meta name="generator" content="Quartz"/><link href="../../../index.css" rel="stylesheet" type="text/css" data-persist="true"/><style>.expand-button {
  position: absolute;
  display: flex;
  float: right;
  padding: 0.4rem;
  margin: 0.3rem;
  right: 0;
  color: var(--gray);
  border-color: var(--dark);
  background-color: var(--light);
  border: 1px solid;
  border-radius: 5px;
  opacity: 0;
  transition: 0.2s;
}
.expand-button > svg {
  fill: var(--light);
  filter: contrast(0.3);
}
.expand-button:hover {
  cursor: pointer;
  border-color: var(--secondary);
}
.expand-button:focus {
  outline: 0;
}

pre:hover > .expand-button {
  opacity: 1;
  transition: 0.2s;
}

#mermaid-container {
  position: fixed;
  contain: layout;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: none;
  backdrop-filter: blur(4px);
  background: rgba(0, 0, 0, 0.5);
}
#mermaid-container.active {
  display: inline-block;
}
#mermaid-container > #mermaid-space {
  border: 1px solid var(--lightgray);
  background-color: var(--light);
  border-radius: 5px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: 80vh;
  width: 80vw;
  overflow: hidden;
}
#mermaid-container > #mermaid-space > .mermaid-content {
  padding: 2rem;
  position: relative;
  transform-origin: 0 0;
  transition: transform 0.1s ease;
  overflow: visible;
  min-height: 200px;
  min-width: 200px;
}
#mermaid-container > #mermaid-space > .mermaid-content pre {
  margin: 0;
  border: none;
}
#mermaid-container > #mermaid-space > .mermaid-content svg {
  max-width: none;
  height: auto;
}
#mermaid-container > #mermaid-space > .mermaid-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--light);
  border: 1px solid var(--lightgray);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid var(--lightgray);
  background: var(--light);
  color: var(--dark);
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  font-family: var(--bodyFont);
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:hover {
  background: var(--lightgray);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:active {
  transform: translateY(1px);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:nth-child(2) {
  width: auto;
  padding: 0 12px;
  font-size: 14px;
}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvaW0weDBpbmctYmxvZy1wcml2YXRlL2ltMHgwaW5nLWJsb2ctcHJpdmF0ZS9xdWFydHovY29tcG9uZW50cy9zdHlsZXMiLCJzb3VyY2VzIjpbIm1lcm1haWQuaW5saW5lLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7O0FBR0Y7RUFDRTtFQUNBOztBQUdGO0VBQ0U7OztBQUtGO0VBQ0U7RUFDQTs7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7O0FBR0Y7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFOztBQUdGO0VBQ0U7O0FBSUY7RUFDRTtFQUNBO0VBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhwYW5kLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nOiAwLjRyZW07XG4gIG1hcmdpbjogMC4zcmVtO1xuICByaWdodDogMDsgLy8gTk9URTogcmlnaHQgd2lsbCBiZSBzZXQgaW4gbWVybWFpZC5pbmxpbmUudHNcbiAgY29sb3I6IHZhcigtLWdyYXkpO1xuICBib3JkZXItY29sb3I6IHZhcigtLWRhcmspO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodCk7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuMnM7XG5cbiAgJiA+IHN2ZyB7XG4gICAgZmlsbDogdmFyKC0tbGlnaHQpO1xuICAgIGZpbHRlcjogY29udHJhc3QoMC4zKTtcbiAgfVxuXG4gICY6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXNlY29uZGFyeSk7XG4gIH1cblxuICAmOmZvY3VzIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG59XG5cbnByZSB7XG4gICY6aG92ZXIgPiAuZXhwYW5kLWJ1dHRvbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiAwLjJzO1xuICB9XG59XG5cbiNtZXJtYWlkLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgY29udGFpbjogbGF5b3V0O1xuICB6LWluZGV4OiA5OTk7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBkaXNwbGF5OiBub25lO1xuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuXG4gICYuYWN0aXZlIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAmID4gI21lcm1haWQtc3BhY2Uge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGhlaWdodDogODB2aDtcbiAgICB3aWR0aDogODB2dztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgJiA+IC5tZXJtYWlkLWNvbnRlbnQge1xuICAgICAgcGFkZGluZzogMnJlbTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgbWluLXdpZHRoOiAyMDBweDtcblxuICAgICAgcHJlIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIHN2ZyB7XG4gICAgICAgIG1heC13aWR0aDogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgfVxuICAgIH1cblxuICAgICYgPiAubWVybWFpZC1jb250cm9scyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDIwcHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDhweDtcbiAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWxpZ2h0KTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgICAgei1pbmRleDogMjtcblxuICAgICAgLm1lcm1haWQtY29udHJvbC1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHQpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZGFyayk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5Rm9udCk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0eWxlIHRoZSByZXNldCBidXR0b24gZGlmZmVyZW50bHlcbiAgICAgICAgJjpudGgtY2hpbGQoMikge1xuICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ== */</style><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" data-persist="true"/><script src="../../../prescript.js" type="application/javascript" data-persist="true"></script><script type="application/javascript" data-persist="true">const fetchData = fetch("../../../static/contentIndex.json").then(data => data.json())</script><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://im0x0ing.github.io/index.xml"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image" content="https://im0x0ing.github.io/技术积累/Golang/核心知识/04-内存模型与分配机制-og-image.webp"/><meta property="og:image:url" content="https://im0x0ing.github.io/技术积累/Golang/核心知识/04-内存模型与分配机制-og-image.webp"/><meta name="twitter:image" content="https://im0x0ing.github.io/技术积累/Golang/核心知识/04-内存模型与分配机制-og-image.webp"/><meta property="og:image:type" content="image/.webp"/></head><body data-slug="技术积累/Golang/核心知识/04-内存模型与分配机制"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="../../..">ING wiki</a></h2><div class="spacer mobile-only"></div><div class="flex-component" style="flex-direction: row; flex-wrap: nowrap; gap: 1rem;"><div style="flex-grow: 1; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><div class="search"><button class="search-button"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg><p>Search</p></button><div class="search-container"><div class="search-space"><input autocomplete="off" class="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div class="search-layout" data-preview="true"></div></div></div></div></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="readermode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="readerIcon" fill="currentColor" stroke="currentColor" stroke-width="0.2" stroke-linecap="round" stroke-linejoin="round" width="64px" height="64px" viewBox="0 0 24 24" aria-label="Reader mode"><title>Reader mode</title><g transform="translate(-1.8, -1.8) scale(1.15, 1.2)"><path d="M8.9891247,2.5 C10.1384702,2.5 11.2209868,2.96705384 12.0049645,3.76669482 C12.7883914,2.96705384 13.8709081,2.5 15.0202536,2.5 L18.7549359,2.5 C19.1691495,2.5 19.5049359,2.83578644 19.5049359,3.25 L19.5046891,4.004 L21.2546891,4.00457396 C21.6343849,4.00457396 21.9481801,4.28672784 21.9978425,4.6528034 L22.0046891,4.75457396 L22.0046891,20.25 C22.0046891,20.6296958 21.7225353,20.943491 21.3564597,20.9931534 L21.2546891,21 L2.75468914,21 C2.37499337,21 2.06119817,20.7178461 2.01153575,20.3517706 L2.00468914,20.25 L2.00468914,4.75457396 C2.00468914,4.37487819 2.28684302,4.061083 2.65291858,4.01142057 L2.75468914,4.00457396 L4.50368914,4.004 L4.50444233,3.25 C4.50444233,2.87030423 4.78659621,2.55650904 5.15267177,2.50684662 L5.25444233,2.5 L8.9891247,2.5 Z M4.50368914,5.504 L3.50468914,5.504 L3.50468914,19.5 L10.9478955,19.4998273 C10.4513189,18.9207296 9.73864328,18.5588115 8.96709342,18.5065584 L8.77307039,18.5 L5.25444233,18.5 C4.87474657,18.5 4.56095137,18.2178461 4.51128895,17.8517706 L4.50444233,17.75 L4.50368914,5.504 Z M19.5049359,17.75 C19.5049359,18.1642136 19.1691495,18.5 18.7549359,18.5 L15.2363079,18.5 C14.3910149,18.5 13.5994408,18.8724714 13.0614828,19.4998273 L20.5046891,19.5 L20.5046891,5.504 L19.5046891,5.504 L19.5049359,17.75 Z M18.0059359,3.999 L15.0202536,4 L14.8259077,4.00692283 C13.9889509,4.06666544 13.2254227,4.50975805 12.7549359,5.212 L12.7549359,17.777 L12.7782651,17.7601316 C13.4923805,17.2719483 14.3447024,17 15.2363079,17 L18.0059359,16.999 L18.0056891,4.798 L18.0033792,4.75457396 L18.0056891,4.71 L18.0059359,3.999 Z M8.9891247,4 L6.00368914,3.999 L6.00599909,4.75457396 L6.00599909,4.75457396 L6.00368914,4.783 L6.00368914,16.999 L8.77307039,17 C9.57551536,17 10.3461406,17.2202781 11.0128313,17.6202194 L11.2536891,17.776 L11.2536891,5.211 C10.8200889,4.56369974 10.1361548,4.13636104 9.37521067,4.02745763 L9.18347055,4.00692283 L8.9891247,4 Z"></path></g></svg></button></div></div><div class="explorer" data-behavior="link" data-collapsed="collapsed" data-savestate="true" data-data-fns="{&quot;order&quot;:[&quot;filter&quot;,&quot;map&quot;,&quot;sort&quot;],&quot;sortFn&quot;:&quot;(a,b)=>!a.isFolder&amp;&amp;!b.isFolder||a.isFolder&amp;&amp;b.isFolder?a.displayName.localeCompare(b.displayName,void 0,{numeric:!0,sensitivity:\&quot;base\&quot;}):!a.isFolder&amp;&amp;b.isFolder?1:-1&quot;,&quot;filterFn&quot;:&quot;node=>node.slug===\&quot;\&quot;||node.slug.startsWith(\&quot;\\u6280\\u672F\\u79EF\\u7D2F\&quot;)&quot;,&quot;mapFn&quot;:&quot;node=>node&quot;}"><button type="button" class="explorer-toggle mobile-explorer hide-until-loaded" data-mobile="true" aria-controls="explorer-27"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" class="title-button explorer-toggle desktop-explorer" data-mobile="false" aria-expanded="true"><h2>Explorer</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-27" class="explorer-content" aria-expanded="false" role="group"><ul class="explorer-ul overflow" id="list-1"><li class="overflow-end"></li></ul></div><template id="template-file"><li><a href="#"></a></li></template><template id="template-folder"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div><button class="folder-button"><span class="folder-title"></span></button></div></div><div class="folder-outer"><ul class="content"></ul></div></li></template></div></div><div class="center"><div class="page-header"><header><nav class="my-navbar "><div class="links"><a href="/课程笔记/">课程笔记</a><a href="/技术积累/">技术积累</a><a href="/工具使用/">工具使用</a><a href="/生活杂谈/">生活杂谈</a></div></nav></header><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../技术积累/">技术积累</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../技术积累/Golang/">Golang</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../技术积累/Golang/核心知识/">核心知识</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>04 内存模型与分配机制</a></div></nav><h1 class="article-title">04 内存模型与分配机制</h1><p show-comma="true" class="content-meta"><time datetime="2025-12-24T21:20:00.000Z">Dec 24, 2025</time><span>37 min read</span></p></div></div><article class="popover-hint"><ul>
<li>mcache: 每个p自己的缓存,各种规格的mspan都缓存一份.不需要锁</li>
<li>mcentral: 某种特定规格的mspan的集合,如果p自己的缓存使用完了,就到mcentral里获取.需要锁.</li>
<li>mheap: 如果mcentral也没有了,就要到mheap申请,这里必须严格加锁,性能最慢.管理的是堆和页,而不是mspan.</li>
<li>如果mheap也没有了,就得向操作系统申请虚拟内存</li>
</ul>
<h2 id="内存模型">内存模型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存模型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h4 id="回顾操作系统">回顾操作系统<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#回顾操作系统" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<ul>
<li>操作系统中经典的多级存储模型设计.
<ul>
<li>多级模型:根据读取速度\空间大小\价格的不同
<ul>
<li>寄存器</li>
<li>高速缓存</li>
<li>内存</li>
<li>磁盘</li>
</ul>
</li>
<li>动态切换</li>
</ul>
</li>
<li>虚拟内存与物理内存:
<ul>
<li>在用户与硬件间添加中间代理层（没有什么是加一个中间层解决不了的）</li>
<li>优化用户体验（进程感知到获得的内存空间是“连续”的）</li>
<li>“放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</li>
</ul>
</li>
<li>分页管理:
<ul>
<li>操作系统中通常会将虚拟内存和物理内存切割成固定的尺寸，于虚拟内存而言叫作“页”，于物理内存而言叫作“帧”，原因及要点如下：
<ul>
<li>提高内存空间利用（以页为粒度后，消灭了不稳定的外部碎片，取而代之的是相对可控的内部碎片）</li>
<li>提高内外存交换效率（更细的粒度带来了更高的灵活度）</li>
<li>与虚拟内存机制呼应，便于建立虚拟地址<span>→</span>物理地址的映射关系（聚合映射关系的数据结构，称为页表）</li>
<li>linux 页/帧的大小固定，为 4KB（这实际是由实践推动的经验值，太粗会增加碎片率，太细会增加分配频率影响效率）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="go内存模型">go内存模型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go内存模型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>核心要点:</p>
<ol>
<li><strong>空间换时间,一次缓存,多次复用.</strong><br/>
因为申请内存的操作很重,那么一次多申请一些.<br/>
Golang中的堆mheap:</li>
</ol>
<ul>
<li>对操作系统而言,这是用户进程中缓存的内存</li>
<li>对于go进程内部,堆是所有对象的内存起源</li>
</ul>
<ol>
<li><strong>多级缓存,实现无/细锁化</strong><br/>
堆是Go运行时最大的临界共享资源,这意味着每次存取都要加锁.<br/>
Golang在堆之上依次细化力度:</li>
</ol>
<ul>
<li>mheap:全局内存起源,访问要加全局锁</li>
<li>mcentral:<strong>每种</strong>对象大小规格(全局共划分为68种)对应的缓存,锁的粒度也仅限于同一种规格以内.mcentral是同种规格的mspan连接而成的一个链表</li>
<li>mcache:每个P持有一份的内存缓存,访问时无锁.</li>
</ul>
<ol>
<li><strong>多级规格,提高利用率</strong></li>
</ol>
<ul>
<li>page 最小的存储单元.类似于操作系统的分页,但是大小是8kb</li>
<li>mspan 最小的管理单元 大小为page的整数倍,被划分为从8b到80kb67种不同的规格<span class="orange-comment">[一个mspanl里面只有一种规格]</span>.<span class="orange-comment">[是再划分,和页的大小无关了.划分后的小块叫做object,object的数量叫nelems]</span> 分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间.
<ul>
<li>多规格 mspan 下产生的特点：
<ul>
<li>根据规格大小，产生了等级的制度</li>
<li>消除了外部碎片，但不可避免会有内部碎片.宏观上能提高整体空间利用率</li>
<li>正是因为有了规格等级的概念，才支持 mcentral 实现细锁化,因为申请的是不同规格的mspan,不需要去全局争夺锁.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="核心概念梳理">核心概念梳理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#核心概念梳理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="内存单元mspan">内存单元mspan<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存单元mspan" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>mspan 是 Golang <strong>内存管理</strong>的最小单元</li>
<li>mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样）</li>
<li>每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级</li>
<li>同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）</li>
<li>由于同等级的 mspan 内聚于同一个 mcentral，所以会<strong>基于同一把互斥锁管理</strong></li>
<li>mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小）此时需要使用到 Ctz64 算法.</li>
<li><img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251215175607.png" width="auto" height="auto" alt/></li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mspan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 标识前后节点的指针 </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 起始地址</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    startAddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 包含几页，页是连续的</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    npages    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 标识此前的位置都已被占用 </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freeindex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 最多可以存放多少个 object</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nelems </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // number of object in the span.</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // bitmap 每个 bit 对应一个 object 块，标识该块是否已被占用</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allocCache </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//64位,每一位代表一个格子的状态0为占用1为空.cpu有一条特殊指令可以对二进制进行O(1)的查询找到二进制中的1的位置</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //如果这 64 位都用完了（全是 0），再从大位图中加载下 64 位进来补充</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 标识 mspan 等级，包含 class 和 noscan 两部分信息</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //size class 前7位 可以查询这里面划分的object大小</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //noscan 最后一位 是免扫描标记,gc看到这个标记,就知道里面存的对象不包含指针,不需要沿着指针打开往下扫描.</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    spanclass    </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h3 id="内存单元等级spanclass">内存单元等级spanClass<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存单元等级spanclass" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>mspan 根据空间大小和面向分配对象的大小，被划分为 67 种等级（1-67，实际上还有一种隐藏的 0 级，用于处理更大的对象，上不封顶）<br/>
<img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251216154725.png" width="auto" height="auto" alt/></p>
<ul>
<li>class: mspan等级标识</li>
<li>bytes/obj：该大小规格的对象会从这一 mspan 中获取空间. 创建对象过程中，<strong>大小会向上取整为 8B 的整数倍</strong>，因此该表可以直接实现 object 到 mspan 等级 的映射</li>
<li>bytes/span：该等级的 mspan 的总空间大小</li>
<li>object：该等级的 mspan 最多可以 new 多少个对象，结果等于 （3）/（2）</li>
<li>tail waste：（ 3）/（2）可能除不尽，于是该项值为（3）%（2）</li>
<li>max waste：通过下面示例解释：</li>
</ul>
<blockquote>
<p>以 class 3 的 mspan 为例，class 分配的 object 大小统一为 24B，由于 object 大小 <span>⇐</span> 16B 的会被分配到 class 2 及之前的 class 中，因此只有 17B-24B 大小的 object 会被分配到 class 3.</p>
</blockquote>
<p>最不利的情况是，当 object 大小为 17B，会产生浪费空间比例如下：</p>
<pre><code> ((24-17)*341 + 8)/8192 = 0.292358 ≈ 29.24%
</code></pre>
<p>除了上面谈及的根据大小确定的 mspan 等级外，每个 object 还有一个重要的属性叫做 nocan，标识了 object 是否包含指针，在 gc 时是否需要展开标记.</p>
<p>在 Golang 中，会将 span class + nocan 两部分信息组装成一个 uint8，形成完整的 spanClass 标识. 8 个 bit 中，高 7 位表示了上表的 span 等级（总共 67 + 1 个等级，8 个 bit 足够用了），最低位表示 nocan 信息.</p>
<h3 id="线程缓存mcache">线程缓存mcache<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#线程缓存mcache" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>（1）mcache 是每个 P 独有的缓存，因此交互无锁<br/>
（2）mcache 将<strong>每种 spanClass 等级</strong>(是否scan算作同一个等级的两种mspan)的 mspan 各缓存了一个，总数为 2（nocan 维度） * 68（大小维度）= 136<br/>
（3）mcache 中还有一个为对象分配器 tiny allocator，用于处理小于 16B 对象的内存分配</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numSpanClasses</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 136</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mcache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 微对象分配器相关</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tiny       </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tinyoffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tinyAllocs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // mcache 中缓存的 mspan，每种 spanClass 各一个</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alloc [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">numSpanClasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h3 id="中心缓存mcentral">中心缓存mcentral<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#中心缓存mcentral" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>（1）每个 mcentral 对应一种 spanClass<br/>
（2）每个 mcentral 下聚合了该 spanClass 下的 mspan<br/>
（3）mcentral 下的 mspan 分为两个链表，分别为有空间 mspan 链表 partial 和满空间 mspan 链表 full<br/>
（4）每个 mcentral 一把锁</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mcentral</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 对应的 spanClass</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    spanclass </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spanClass</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 有空位的 mspan 集合，数组长度为 2 是用于抗一轮 GC</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    partial [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spanSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 无空位的 mspan 集合</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    full    [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spanSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h3 id="全局堆缓存mheap">全局堆缓存mheap<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#全局堆缓存mheap" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>• 对于 Golang 上层应用而言，堆是操作系统虚拟内存的抽象<br/>
• 以页（8KB）为单位，作为最小内存存储单元<br/>
• 负责将连续页组装成 mspan<br/>
• 全局内存基于 bitMap 标识其使用情况，每个 bit 对应一页，为 0 则自由，为 1 则已被 mspan 组装<br/>
• 通过 heapArena 聚合页，记录了页到 mspan 的映射信息（2.7小节展开）<br/>
• 建立空闲页基数树索引 radix tree index，辅助快速寻找空闲页（2.6小节展开）<br/>
• 是 mcentral 的持有者，持有所有 spanClass 下的 mcentral，作为自身的缓存<br/>
• 内存不够时，向操作系统申请，申请单位为 heapArena（64M）</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mheap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 堆的全局锁</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lock </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mutex</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 空闲页分配器，底层是多棵基数树组成的索引，每棵树对应 16 GB 内存空间</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pages </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pageAlloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 记录了所有的 mspan. 需要知道，所有 mspan 都是经由 mheap，使用连续空闲页组装生成的</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allspans []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // heapAreana 数组，64 位系统下，二维数组容量为 <span class="orange-comment">[1]</span><span class="orange-comment">[2^22]</span></span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 每个 heapArena 大小 64M，因此理论上，Golang 堆上限为 2^22*64M = 256T</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arenas [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arenaL1Bits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arenaL2Bits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">heapArena</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 多个 mcentral，总个数为 spanClass 的个数</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    central [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">numSpanClasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        mcentral </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcentral</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 用于内存地址对齐</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pad      [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CacheLinePadSize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcentral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CacheLinePadSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h3 id="空闲页索引-pagealloc">空闲页索引 pageAlloc<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#空闲页索引-pagealloc" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ol>
<li>数据结构背后的含义
<ol>
<li>mheap会基于bitMap标识内存中各页的使用情况,bit位为0代表该页空闲,为1代表该页已被mspan占用</li>
<li>每棵基数树聚合了16GB内存空间中各页使用情况的索引信息,用于帮助mheap快速找到指定长度的连续空闲页的所在位置</li>
<li>mheap持有2的14次方棵基数树,因此索引全面覆盖到2的114次方*16gb=256T的内存空间</li>
</ol>
</li>
<li>基数树设定</li>
</ol>
<ul>
<li>基数树中，每个节点称之为 PallocSum，是一个 uint64 类型，体现了索引的聚合信息，包含以下四部分：
<ul>
<li>start：最右侧 21 个 bit，标识了当前节点映射的 bitMap 范围中首端有多少个连续的 0 bit（空闲页）称之为 start；<br/>
- max：中间 21 个 bit，标识了当前节点映射的 bitMap 范围中最多有多少个连续的 0 bit（空闲页）称之为 max；</li>
<li>end：左侧 21 个 bit，标识了当前节点映射的 bitMap 范围中最末端有多少个连续的 0 bit（空闲页）称之为 end.</li>
<li>最左侧一个 bit，弃置不用<img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251216164725.png" width="auto" height="auto" alt/><br/>
总之就是利用基数树快速查找空闲页</li>
</ul>
</li>
</ul>
<h4 id="heaparena">heapArena<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#heaparena" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<ul>
<li>每个 heapArena 包含 8192 个页，大小为 8192 * 8KB = 64 MB</li>
<li>heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.</li>
<li>heapArena 是 mheap 向操作系统申请内存的单位（64MB）</li>
</ul>
<h2 id="对象分配流程">对象分配流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#对象分配流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>下面来串联 Golang 中分配对象的流程，不论是以下哪种方式，最终都会殊途同归步入 mallocgc 方法中，并且根据 3.1 小节中的策略执行分配流程：</p>
<ul>
<li>new(T)<br/>
- &amp;T{}</li>
<li>make(xxxx)</li>
</ul>
<h3 id="流程总览">流程总览<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#流程总览" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>在golang中,依据object的大小,将其分为三类</p>
<ul>
<li>tiny 微对象(0,16B)</li>
<li>small 小对象<span class="orange-comment">[16B,32KB]</span></li>
<li>large 大对象(32KB,∞)</li>
</ul>
<p>不同类型的对象，会有着不同的分配策略，这些内容在 mallocgc 方法中都有体现.<br/>
核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p>
<ul>
<li>
<p>对于<strong>微对象</strong>的分配流程：<br/>
（1）从 P 专属 mcache 的 <span class="text-highlight">tiny 分配器</span>取内存（无锁）<br/>
（2）根据所属的 spanClass，从 P 专属 mcache <span class="text-highlight">缓存的 mspan</span> 中取内存（无锁）<br/>
（3）根据所属的 spanClass 从<span class="text-highlight">对应的 mcentral 中</span>取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）<br/>
（4）根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）<br/>
（5）mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复（4）.</p>
</li>
<li>
<p>对于<strong>小对象</strong>的分配流程是跳过（1）步，执行上述流程的（2）-（5）步；</p>
</li>
<li>
<p>对于<strong>大对象</strong>的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步.<span class="orange-comment">[mspan最大的规格只有32KB]</span></p>
</li>
</ul>
<h3 id="主干方法mallocgc">主干方法mallocgc<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#主干方法mallocgc" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mallocgc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">typ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">needzero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 获取 m</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> acquirem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 获取当前 p 对应的 mcache</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getMCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mp)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> span </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 根据当前对象是否包含指针，标识 gc 时是否需要展开扫描</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    noscan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> typ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> typ.ptrdata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 是否是小于 32KB 的微、小对象</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxSmallSize {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 小于 16 B 且无指针，则视为微对象</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> noscan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxTinySize {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // tiny 内存块中，从 offset 往后有空闲位置</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.tinyoffset</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 如果大小为 5 ~ 8 B，size 会被调整为 8 B，此时 8 &amp; 7 == 0，会走进此分支</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 将 offset 补齐到 8 B 倍数的位置</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alignUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(off, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 如果大小为 3 ~ 4 B，size 会被调整为 4 B，此时 4 &amp; 3 == 0，会走进此分支  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 将 offset 补齐到 4 B 倍数的位置</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alignUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(off, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 如果大小为 1 ~ 2 B，size 会被调整为 2 B，此时 2 &amp; 1 == 0，会走进此分支  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 将 offset 补齐到 2 B 倍数的位置</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alignUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(off, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果当前 tiny 内存块空间还够用，则直接分配并返回</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxTinySize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.tiny </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 分配空间</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c.tiny </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                c.tinyoffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                c.tinyAllocs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mp.mallocing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                releasem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mp)  </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 分配一个新的 tiny 内存块</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            span </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.alloc<span class="orange-comment">[tinySpanClass]</span>    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 从 mCache 中获取</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextFreeFast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(span)        </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 从 mCache 中获取失败，则从 mCentral 或者 mHeap 中获取进行兜底</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                v, span, shouldhelpgc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextFree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tinySpanClass)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }   </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 分配空间      </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(x)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(x)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxTinySize</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sizeclass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> smallSizeMax</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              sizeclass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_to_class8[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">divRoundUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size, smallSizeDiv)]</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              sizeclass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size_to_class128[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">divRoundUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">smallSizeMax, largeSizeDiv)]</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }        </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(class_to_size<span class="orange-comment">[sizeclass]</span>)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 创建 spanClass 标识，其中前 7 位对应为 span 的等级(0~66)，最后标识表示了这个对象 gc 时是否需要扫描</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          spc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeSpanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sizeclass, noscan) </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 获取 mcache 中的 span</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          span </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.alloc<span class="orange-comment">[spc]</span>  </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 从 mcache 的 span 中尝试获取空间        </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextFreeFast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(span)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             v, span, shouldhelpgc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextFree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(spc)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }     </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 分配空间  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }      </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 大于 32KB 的大对象      </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 从 mheap 中获取 0 号 span</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       span </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocLarge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size, noscan)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       span.freeindex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       span.allocCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> span.elemsize         </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 分配空间   </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(span.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }  </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}                               </span></span></code></pre></figure>
<h4 id="tiny分配">tiny分配<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tiny分配" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><strong>每个 P 独有的 mache</strong> 会有个微对象分配器，基于 offset 线性移动的方式对微对象进行分配，每 16B 成块，对象依据其大小，会向上取整为 2 的整数次幂进行空间补齐，然后进入分配流程.</p>
<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Title </p></div>
                  
                </div>
<div class="callout-content">
<p>内存分配中,最小的分配单位是八字节,就算只存一个bool,也会给一个八字节的格子.是 <code>mcache</code> 先去申请一个普通的 mspan（比如 class 2）然后从里面拿出一个 16B 的块，专门标记为“现在的 tiny block”，然后开始往里面塞东西.   避免内部碎片</p>
</div>
</blockquote>
<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Title </p></div>
                  
                </div>
<div class="callout-content">
<p>编译期结束后,就已经知道要为什么变量申请什么内存.只是把产生的tinyobject变量按照一定的规则塞进mcache的tiny block里面</p>
</div>
</blockquote>
<p><img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251216172823.png" width="auto" height="auto" alt/></p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    noscan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> typ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> typ.ptrdata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //只收不含指针且大小小于 16B的对象</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> noscan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxTinySize {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // tiny 内存块中，从 offset 往后有空闲位置</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.tinyoffset</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // off 此时是经过“对齐算法”调整后的新偏移量</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // `c.tiny` 指向当前那个 16B 的内存块的**起始地址**。`c.tinyoffset` 是一个游标，记录当前用到哪里了。</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 如果当前 tiny 内存块空间还够用，则直接分配并返回</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxTinySize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.tiny </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 分配空间</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c.tiny </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//计算内存地址</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                c.tinyoffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> off </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//更新游标</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                c.tinyAllocs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//统计数据</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mp.mallocing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//恢复状态</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                releasem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mp)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //都是纳秒级操作,基本等同于CPU的加法指令</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></figure>
<h4 id="mcache分配">mcache分配<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#mcache分配" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>宏观流程</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          //比如申请 20字节，Go 会匹配到 32字节 的规格,这个sizeclass是一个编号id.比如32B对应编号是3</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sizeclass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // get size class ....     </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 但是同一个size  还有两种span .spanclass就是,sizeclaass左移一位,最后一位标记是否noscan</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          //get span class</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          spc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeSpanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sizeclass, noscan) </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          //c 是 mcache，alloc 是一个数组 <span class="orange-comment">[134]</span>*mspan。这就是用spanclass把span拿出来</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          //这里拿出来完全不需要加锁,因为mcache是绑定在p上的</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          span </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.alloc<span class="orange-comment">[spc]</span>  </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 从 mcache 的 span 中尝试获取空间.这里的nextFreeFast是极速地指一个空座位.span结构体里面有一个allocCache,有64个bit,缓存了当前的座位中接下来64个座位的空闲状态</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          //这个 allocCache 被加载到了 CPU 的寄存器 中。 CPU 有一条特殊的指令（TZCNT 或 BSF，Go 里的 sys.Ctz64），它能在一个 CPU 周期内，直接算出这个 64 位的数字里，倒数第几位是 1。</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextFreeFast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(span)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // mcache 分配空间失败，则通过 mcentral、mheap 兜底 </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 这里的nextfree.这个方法可能会1. 刷新位图:加载下64个槽位的状态.2.如果mspan彻底满了,就向mcentral申请新的span<span class="orange-comment">[Refill]</span></span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             v, span, shouldhelpgc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextFree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(spc)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }     </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 分配空间  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span></code></pre></figure>
<p>微观算法</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextFreeFast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gclinkptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 通过 ctz64 算法，在 bit map 上寻找到首个 object 空位</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    theBit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sys.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Ctz64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s.allocCache) </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> theBit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//如果返回64的话说明没有找到.返回&lt;64的数字就是这非0bit的位置</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	    //计算全局索引,要加上freeindex:也就是alloccache对应的起始游标</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.freeindex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(theBit)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //边界检查</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.nelems {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这个nelems是当前span总共能容纳的对象数</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            freeidx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freeidx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freeidx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.nelems {</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//如果刚好用完了当前的64位,且span还有剩余的对象,那么可以退出去慢分配.</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //更新位图,向右移动多少多少位,变成theBit的接下来64位</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            s.allocCache </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">>>=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(theBit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 更新 freeindex </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            s.freeindex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freeidx</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            s.allocCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 返回获取 object 空位的内存地址 </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gclinkptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s.elemsize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//比如分配到了第二个对象,那么计算实际的地址</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h4 id="mcentral分配">mcentral分配<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#mcentral分配" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>tiny分配和mcache分配都失败之后,就会进入这个慢分配路径</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextFree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">spc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gclinkptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">shouldhelpgc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.alloc<span class="orange-comment">[spc]</span></span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//从mcache里面把特定spanclass的span拿出来</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 从 mcache 的 span 中获取 object 空位的偏移量</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freeIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextFreeIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freeIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.nelems {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 倘若 mcache 中 span 已经没有空位，则调用 refill 方法从 mcentral 或者 mheap 中获取新的 span    </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(spc)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 再次从替换后的 span 中获取 object 空位的偏移量</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.alloc<span class="orange-comment">[spc]</span></span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        freeIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextFreeIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gclinkptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(freeIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s.elemsize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s.allocCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}    </span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">spc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.alloc<span class="orange-comment">[spc]</span></span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // mheap_.central<span class="orange-comment">[spc]</span>：根据规格 (spanClass)，找到管理这种规格的中心仓库。</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 调用 .cacheSpan() 方法，让 mcentral 给一个可用的 span。</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mheap_.central<span class="orange-comment">[spc]</span>.mcentral.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cacheSpan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将新的 span 添加到 mcahe 当中</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c.alloc<span class="orange-comment">[spc]</span> </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<p>mcentral管理着两个链表</p>
<ul>
<li>partial:有空闲空间的span</li>
<li>full:被认为是满的span</li>
</ul>
<blockquote>
<p><strong>GC（服务员）的工作 - 标记：</strong> 服务员（GC）每隔一小时巡视一圈。他<strong>不收盘子</strong>，只是看哪张桌子的客人都走光了，就在桌子上贴个“可回收”的标签（Marking）。经理指着账本 B 上的一张桌子说：“这一桌，你过去看看。” 领位员走过去（<code>Acquire</code> 锁定），发现桌子上贴着“可回收”，于是顺手把盘子收了（Sweep）。 瞬间，一张“满桌”变成了“空桌”。领位员就可以安排新客人入座了。把清理垃圾的开销，<strong>平摊（Amortize）</strong> 到了每一次内存分配中。</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcentral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cacheSpan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sl </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sweepLocker</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //特殊的锁,用于并发清扫 </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sweep.active.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">begin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sl.valid {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //尝试从partial部分找</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; spanBudget </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">>=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; spanBudget</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">partialUnswept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sg).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//partialUnswept里面存的是上次看还有空位,但是还没清扫过的span,先拿出来一个</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //尝试获取tryAcquire,这个动作会触发sweep清扫,如果有垃圾被回收,这里就会成功</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s, ok </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tryAcquire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s); ok {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                sweep.active.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sl)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> havespan</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//成功了那么跳转结尾</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            /-</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 通过 sweepLock，加锁尝试从 mcentral 的非空链表 full 中获取 mspan</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; spanBudget </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">>=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; spanBudget</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fullUnswept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sg).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//拿出一个原本满的</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           //尝试清扫</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s, ok </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tryAcquire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s); ok {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                sweep.active.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sl)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> havespan</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//如果腾出了空间那么跳转结尾</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                } </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这里如果partial和full都没货,会调用c.grow向mheap申请新的内存页</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行到此处时，s 已经指向一个存在 object 空位的 m0span 了</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">havespan:</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span></code></pre></figure>
<p>sweeplocker</p>
<ol>
<li>核心,cas(compare and swap) <img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251224195830.png" width="auto" height="auto" alt/></li>
<li>双重身份验证sweep.active<img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251224195908.png" width="auto" height="auto" alt/></li>
<li>不阻塞<img src="../../../技术积累/Golang/核心知识/attachments/Pasted-image-20251224195956.png" width="auto" height="auto" alt/><br/>
这个begin和end,是对当前p的清扫状态的注册和注销,便于更新全局gc统计信息.</li>
</ol>
<h4 id="mheap分配">mheap分配<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#mheap分配" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>如何在一个碎片化的内存空间里,快速找到连续的n个空闲页?</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcentral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cacheSpan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // mcentral 中也没有可用的 mspan 了，则需要从 mheap 中获取，最终会调用 mheap_.alloc 方法</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // ...</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行到此处时，s 已经指向一个存在 object 空位的 mspan 了</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">havespan:</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcentral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//计算进货量</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// class_to_allocnpages 是一个预定义的数组。 </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 比如：你要申请 sizeclass=3 的对象，Go 规定这种规格的 Span 一次必须申请 1 页。 </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果是 sizeclass=40，可能规定一次必须申请 5 页。</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//所以这里实际上是,把规格id换算成了具体需要多少物理页数.</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    npages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(class_to_allocnpages[c.spanclass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sizeclass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()])</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //计算总字节数</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(class_to_size[c.spanclass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sizeclass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()])</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//向mheap下单.调用alloc,传入需要的 页数和规格</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mheap_.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(npages, c.spanclass)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mheap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">npages</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">spanclass</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //go会强制切换到g0系统栈来实行这段代码,是m专用的,空间大并且安全</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    systemstack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //在系统栈上安全🉐进行分配逻辑</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocSpan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(npages, spanAllocHeap, spanclass)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mheap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allocSpan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">npages</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">typ</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spanAllocType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">spanclass</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spanClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    base, scav </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...此处实际上还有一阶缓存，是从每个 P 的页缓存 pageCache 中获取空闲页组装 mspan，此处先略去了...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 加上堆全局锁因为mheap是全局唯一的,所有p都在抢夺.是整个内存分配路径中锁竞争最激烈的地方</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h.lock)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> base </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 通过基数树索引快速寻找满足条件的连续空闲页</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //h.pages就是基数树,在基数树上调用alloc找到连续的npages个空闲页</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        base, scav </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h.pages.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(npages)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //如果基数树也找不到内存了,这里会触发grow去操作系统的mmap要内存</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h.lock)</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HaveSpan:</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 把空闲页组装成 mspan</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //比如设置base npages nelems等等</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(base, npages)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将这批页添加到 heapArena 中，建立由页指向 mspan 的映射</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //以后 GC 扫描到一个指针指向这块内存时，查一下 heapArena，就能立马知道它属于哪个 span</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    h.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setSpans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), npages, s)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">```</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">#### 向操作系统申请</span></span>
<span data-line><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">//因为系统调用很贵所以每次都预获取多一点</span></span>
<span data-line><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">```</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mheap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">npage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ask 是经过对齐计算后的字节数。</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    av, asize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sysAlloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ask)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//**含义**：这是中间层，主要负责维护一些统计信息（代码中省略了），并把具体的“保留内存”工作交给 `sysReserve`。</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mheap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sysAlloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sysReserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p), n)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//`sysReserve` 是一个通用接口。在 Linux 下它会调用下面的 `sysReserveOS`，在 Windows 下它会调用 `VirtualAlloc`。它屏蔽了底层操作系统的差异。</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sysReserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sysReserveOS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v, n)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sysReserveOS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// mmap 是 Unix/Linux 系统中最常用的内存映射系统调用。</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 它通常用于文件映射，但加上特定的参数，就变成了“申请堆内存”。</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v, n, _PROT_NONE, _MAP_ANON</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_MAP_PRIVATE, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //v 期望地址.如果传nil,就会随便找一块空地,如果传了具体地址,就会尽量满足</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //n 申请大小</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //PROT NONE 没有任何权限.这块内存申请下来之后没有任何权限,这是保留,Go 在这里只是在操作系统的“账本”上把这块虚拟地址范围占住了，防止被别人用了。但此时，这块内存完全不占用物理 RAM.</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //等到go真的需要使用这块地址的时候,再调用sysMap函数修改权限,这是为了节省物理内存</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //_MAP_ANON|_MAP_PRIVATE 匿名映射\私有映射,说明这块内存不对应磁盘上的任何文件,就是纯粹的RAM堆内存.私有映射表示这块内存是当前进程独享的,不会跟其他进程共享</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //-1 文件描述符,因为匿名映射不需要文件,所以写1</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //0 匿名映射无偏移量,0</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h4 id="基数树寻页">基数树寻页<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#基数树寻页" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>//在一个巨大的内存空间中，高效地找到 <code>N</code> 个连续的空闲页。<br/>
summary是一个五层金字塔结构,L0每个店表示很大的区域,L5直接对应具体的内存页.每个节点sum里面都保存了三个信息,在这一大块区域里面</p>
<ul>
<li>start 开头有多少连续空位</li>
<li>max 内部最大有多少连续空位</li>
<li>end 结尾有多少连续空位</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="go" data-theme="github-light github-dark"><code data-language="go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pageAlloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">npages</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">offAddr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 必须持有堆锁</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertLockHeld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p.mheapLock)</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // current level.</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lastSum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> packPallocSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lastSumIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nextLevel:</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1 ~ 5 层依次遍历</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p.summary); l</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 根据上一层的 index，映射到下一层的 index.</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 映射关系示例：上层 0 -> 下层 <span class="orange-comment">[0~7]</span></span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //             上层 1 -> 下层 <span class="orange-comment">[8~15]</span></span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //             以此类推</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> levelBits<span class="orange-comment">[l]</span></span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//算出我的下属在下一张表里的起始行号,如果一个上司管理8个下属,那么上司要左移3位,可以得到下属的起始号码</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        entries </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.summary<span class="orange-comment">[l]</span>[i : i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">entriesPerBlock]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//拿出所有的下属放到entries里面</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // var levelBits = <span class="orange-comment">[summaryLevels]</span>uint{</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //   14,3,3,3,3</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 除第一层有 2^14 个节点外，接下来每层都只要关心 8 个 节点.</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 由于第一层有 2^14 个节点，所以 heap 内存上限为 2^14 * 16G = 256T</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //一个一个看这些下属</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> base, size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j0; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entries); j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entries<span class="orange-comment">[j]</span></span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // ...</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 倘若当前节点对应内存空间开头即满足，直接返回结果</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">>=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(npages) {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//size:直到这一刻，我手里已经攒着的、紧挨着当前区域左边的、连续空位数</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//不需要拼上一个区域的时候,起点就是当前区域的开头</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    base </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logMaxPages</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//j是当前扫描到的子区域索引,比如第三个小区.然后logMaxPages是一个倍率表示这个小区里面有多少页,所以base=j*小区容量,</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }             </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这就是计算一下总共攒了多少,反正后面break退出循环了.</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 倘若当前节点对应内存空间首部不满足，但是内部最长连续页满足，则到下一层节点展开搜索</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">>=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(npages) {               </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//更新索引,定位到这个子区域 i+j</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                lastSumIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                lastSum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextLevel </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//直接跳到下一层去找.因为知道了最大的连续空位就是我们要的 所以我们继续往下找.</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 即便内部最长连续页不满足，还可以尝试将尾部与下个节点的首部叠加，看是否满足</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logMaxPages {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                base </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logMaxPages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//计算base</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // The entry is completely free, so continue the run.</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logMaxPages</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //**Go 的内存管理架构**： Go 的堆内存不是完全连续的一整块，而是切分成很多巨大的块，叫 **Chunk**（通常是 512MB 一个）。</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 根据 i 和 j 可以推导得到对应的内存地址，进行返回</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //根据我们在树里的索引 `i`，算出这块地皮属于**第几个 Chunk**</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ci </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chunkIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //去查表，问第 5 号 Chunk 在内存里的**真实首地址**是多少？再加上真实的页偏移</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    addr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> chunkBase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ci) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pageSize</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> addr, p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findMappedAddr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(firstFree.base)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure></article><hr/><div class="page-footer"><div class="giscus" data-repo="im0x0ing/im0x0ing.github.io" data-repo-id="R_kgDOQevgrA" data-category="Announcements" data-category-id="DIC_kwDOQevgrM4CzLI8" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-input-position="top" data-light-theme="light" data-dark-theme="dark" data-theme-url="https://im0x0ing.github.io/static/giscus" data-lang="zh-CN"></div></div></div><div class="right sidebar"><div class="toc desktop-only"><button type="button" class="toc-header" aria-controls="toc-6" aria-expanded="true"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div class="toc-depth-control"><span class="depth-label">H3</span><input type="range" class="depth-slider" min="1" max="6" value="2" step="1"/></div><ul id="list-5" class="toc-content overflow"><li class="depth-0"><a href="#内存模型" data-for="内存模型">内存模型</a></li><li class="depth-2"><a href="#回顾操作系统" data-for="回顾操作系统">回顾操作系统</a></li><li class="depth-1"><a href="#go内存模型" data-for="go内存模型">go内存模型</a></li><li class="depth-0"><a href="#核心概念梳理" data-for="核心概念梳理">核心概念梳理</a></li><li class="depth-1"><a href="#内存单元mspan" data-for="内存单元mspan">内存单元mspan</a></li><li class="depth-1"><a href="#内存单元等级spanclass" data-for="内存单元等级spanclass">内存单元等级spanClass</a></li><li class="depth-1"><a href="#线程缓存mcache" data-for="线程缓存mcache">线程缓存mcache</a></li><li class="depth-1"><a href="#中心缓存mcentral" data-for="中心缓存mcentral">中心缓存mcentral</a></li><li class="depth-1"><a href="#全局堆缓存mheap" data-for="全局堆缓存mheap">全局堆缓存mheap</a></li><li class="depth-1"><a href="#空闲页索引-pagealloc" data-for="空闲页索引-pagealloc">空闲页索引 pageAlloc</a></li><li class="depth-2"><a href="#heaparena" data-for="heaparena">heapArena</a></li><li class="depth-0"><a href="#对象分配流程" data-for="对象分配流程">对象分配流程</a></li><li class="depth-1"><a href="#流程总览" data-for="流程总览">流程总览</a></li><li class="depth-1"><a href="#主干方法mallocgc" data-for="主干方法mallocgc">主干方法mallocgc</a></li><li class="depth-2"><a href="#tiny分配" data-for="tiny分配">tiny分配</a></li><li class="depth-2"><a href="#mcache分配" data-for="mcache分配">mcache分配</a></li><li class="depth-2"><a href="#mcentral分配" data-for="mcentral分配">mcentral分配</a></li><li class="depth-2"><a href="#mheap分配" data-for="mheap分配">mheap分配</a></li><li class="depth-2"><a href="#基数树寻页" data-for="基数树寻页">基数树寻页</a></li><li class="overflow-end"></li></ul></div><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div class="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button class="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div class="global-graph-outer"><div class="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.2,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.5.2</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript" data-persist="true">function n(){let t=this.parentElement;t.classList.toggle("is-collapsed");let e=t.getElementsByClassName("callout-content")[0];if(!e)return;let l=t.classList.contains("is-collapsed");e.style.gridTemplateRows=l?"0fr":"1fr"}function c(){let t=document.getElementsByClassName("callout is-collapsible");for(let e of t){let l=e.getElementsByClassName("callout-title")[0],s=e.getElementsByClassName("callout-content")[0];if(!l||!s)continue;l.addEventListener("click",n),window.addCleanup(()=>l.removeEventListener("click",n));let o=e.classList.contains("is-collapsed");s.style.gridTemplateRows=o?"0fr":"1fr"}}document.addEventListener("nav",c);
</script><script type="module" data-persist="true">function f(i,e){if(!i)return;function r(o){o.target===this&&(o.preventDefault(),o.stopPropagation(),e())}function t(o){o.key.startsWith("Esc")&&(o.preventDefault(),e())}i?.addEventListener("click",r),window.addCleanup(()=>i?.removeEventListener("click",r)),document.addEventListener("keydown",t),window.addCleanup(()=>document.removeEventListener("keydown",t))}function y(i){for(;i.firstChild;)i.removeChild(i.firstChild)}var h=class{constructor(e,r){this.container=e;this.content=r;this.setupEventListeners(),this.setupNavigationControls(),this.resetTransform()}isDragging=!1;startPan={x:0,y:0};currentPan={x:0,y:0};scale=1;MIN_SCALE=.5;MAX_SCALE=3;cleanups=[];setupEventListeners(){let e=this.onMouseDown.bind(this),r=this.onMouseMove.bind(this),t=this.onMouseUp.bind(this),o=this.resetTransform.bind(this);this.container.addEventListener("mousedown",e),document.addEventListener("mousemove",r),document.addEventListener("mouseup",t),window.addEventListener("resize",o),this.cleanups.push(()=>this.container.removeEventListener("mousedown",e),()=>document.removeEventListener("mousemove",r),()=>document.removeEventListener("mouseup",t),()=>window.removeEventListener("resize",o))}cleanup(){for(let e of this.cleanups)e()}setupNavigationControls(){let e=document.createElement("div");e.className="mermaid-controls";let r=this.createButton("+",()=>this.zoom(.1)),t=this.createButton("-",()=>this.zoom(-.1)),o=this.createButton("Reset",()=>this.resetTransform());e.appendChild(t),e.appendChild(o),e.appendChild(r),this.container.appendChild(e)}createButton(e,r){let t=document.createElement("button");return t.textContent=e,t.className="mermaid-control-button",t.addEventListener("click",r),window.addCleanup(()=>t.removeEventListener("click",r)),t}onMouseDown(e){e.button===0&&(this.isDragging=!0,this.startPan={x:e.clientX-this.currentPan.x,y:e.clientY-this.currentPan.y},this.container.style.cursor="grabbing")}onMouseMove(e){this.isDragging&&(e.preventDefault(),this.currentPan={x:e.clientX-this.startPan.x,y:e.clientY-this.startPan.y},this.updateTransform())}onMouseUp(){this.isDragging=!1,this.container.style.cursor="grab"}zoom(e){let r=Math.min(Math.max(this.scale+e,this.MIN_SCALE),this.MAX_SCALE),t=this.content.getBoundingClientRect(),o=t.width/2,n=t.height/2,c=r-this.scale;this.currentPan.x-=o*c,this.currentPan.y-=n*c,this.scale=r,this.updateTransform()}updateTransform(){this.content.style.transform=`translate(${this.currentPan.x}px, ${this.currentPan.y}px) scale(${this.scale})`}resetTransform(){this.scale=1;let e=this.content.querySelector("svg");this.currentPan={x:e.getBoundingClientRect().width/2,y:e.getBoundingClientRect().height/2},this.updateTransform()}},C=["--secondary","--tertiary","--gray","--light","--lightgray","--highlight","--dark","--darkgray","--codeFont"],E;document.addEventListener("nav",async()=>{let e=document.querySelector(".center").querySelectorAll("code.mermaid");if(e.length===0)return;E||=await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.esm.min.mjs");let r=E.default,t=new WeakMap;for(let n of e)t.set(n,n.innerText);async function o(){for(let s of e){s.removeAttribute("data-processed");let a=t.get(s);a&&(s.innerHTML=a)}let n=C.reduce((s,a)=>(s[a]=window.getComputedStyle(document.documentElement).getPropertyValue(a),s),{}),c=document.documentElement.getAttribute("saved-theme")==="dark";r.initialize({startOnLoad:!1,securityLevel:"loose",theme:c?"dark":"base",themeVariables:{fontFamily:n["--codeFont"],primaryColor:n["--light"],primaryTextColor:n["--darkgray"],primaryBorderColor:n["--tertiary"],lineColor:n["--darkgray"],secondaryColor:n["--secondary"],tertiaryColor:n["--tertiary"],clusterBkg:n["--light"],edgeLabelBackground:n["--highlight"]}}),await r.run({nodes:e})}await o(),document.addEventListener("themechange",o),window.addCleanup(()=>document.removeEventListener("themechange",o));for(let n=0;n<e.length;n++){let v=function(){let g=l.querySelector("#mermaid-space"),m=l.querySelector(".mermaid-content");if(!m)return;y(m);let w=c.querySelector("svg").cloneNode(!0);m.appendChild(w),l.classList.add("active"),g.style.cursor="grab",u=new h(g,m)},M=function(){l.classList.remove("active"),u?.cleanup(),u=null},c=e[n],s=c.parentElement,a=s.querySelector(".clipboard-button"),d=s.querySelector(".expand-button"),p=window.getComputedStyle(a),L=a.offsetWidth+parseFloat(p.marginLeft||"0")+parseFloat(p.marginRight||"0");d.style.right=`calc(${L}px + 0.3rem)`,s.prepend(d);let l=s.querySelector("#mermaid-container");if(!l)return;let u=null;d.addEventListener("click",v),f(l,M),window.addCleanup(()=>{u?.cleanup(),d.removeEventListener("click",v)})}});
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript" data-persist="true"></script><script src="../../../postscript.js" type="module" data-persist="true"></script></html>