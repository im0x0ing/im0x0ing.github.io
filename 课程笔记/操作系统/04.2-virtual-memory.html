<!DOCTYPE html>
<html lang="en" dir="ltr"><head><title>04.2 virtual memory</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto Sans SC:wght@400;700&amp;family=Noto Serif SC:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700;1,900&amp;family=JetBrains Mono:wght@400;600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="ING wiki"/><meta property="og:title" content="04.2 virtual memory"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="04.2 virtual memory"/><meta name="twitter:description" content="DECK: CS::OS 地址空间与异常 地址空间 (address space) 指的是地址取值的全集。 物理地址空间 例如，对于一个 32 位寻址的体系结构，其 物理地址空间（物理地址的集合）就是 ，亦即 0x00000000 ~ 0xffffffff。 - flat memory内存模型: 在引入分段 / 分页技术之前，各个进程和操作系统共同使用同一个物理地址空间。它会带来比较大的碎片，同时隔离性较差，内存的保护较弱。 虚拟地址空间 而在引入了分段 / 分页技术之后，每个进程都有了自己的一套 logical memory (a.k.a."/><meta property="og:description" content="DECK: CS::OS 地址空间与异常 地址空间 (address space) 指的是地址取值的全集。 物理地址空间 例如，对于一个 32 位寻址的体系结构，其 物理地址空间（物理地址的集合）就是 ，亦即 0x00000000 ~ 0xffffffff。 - flat memory内存模型: 在引入分段 / 分页技术之前，各个进程和操作系统共同使用同一个物理地址空间。它会带来比较大的碎片，同时隔离性较差，内存的保护较弱。 虚拟地址空间 而在引入了分段 / 分页技术之后，每个进程都有了自己的一套 logical memory (a.k.a."/><meta property="og:image:alt" content="DECK: CS::OS 地址空间与异常 地址空间 (address space) 指的是地址取值的全集。 物理地址空间 例如，对于一个 32 位寻址的体系结构，其 物理地址空间（物理地址的集合）就是 ，亦即 0x00000000 ~ 0xffffffff。 - flat memory内存模型: 在引入分段 / 分页技术之前，各个进程和操作系统共同使用同一个物理地址空间。它会带来比较大的碎片，同时隔离性较差，内存的保护较弱。 虚拟地址空间 而在引入了分段 / 分页技术之后，每个进程都有了自己的一套 logical memory (a.k.a."/><meta property="twitter:domain" content="im0x0ing.github.io"/><meta property="og:url" content="https://im0x0ing.github.io/课程笔记/操作系统/04.2-virtual-memory"/><meta property="twitter:url" content="https://im0x0ing.github.io/课程笔记/操作系统/04.2-virtual-memory"/><link rel="icon" href="../../static/icon.png"/><meta name="description" content="DECK: CS::OS 地址空间与异常 地址空间 (address space) 指的是地址取值的全集。 物理地址空间 例如，对于一个 32 位寻址的体系结构，其 物理地址空间（物理地址的集合）就是 ，亦即 0x00000000 ~ 0xffffffff。 - flat memory内存模型: 在引入分段 / 分页技术之前，各个进程和操作系统共同使用同一个物理地址空间。它会带来比较大的碎片，同时隔离性较差，内存的保护较弱。 虚拟地址空间 而在引入了分段 / 分页技术之后，每个进程都有了自己的一套 logical memory (a.k.a."/><meta name="generator" content="Quartz"/><link href="../../index.css" rel="stylesheet" type="text/css" data-persist="true"/><style>.expand-button {
  position: absolute;
  display: flex;
  float: right;
  padding: 0.4rem;
  margin: 0.3rem;
  right: 0;
  color: var(--gray);
  border-color: var(--dark);
  background-color: var(--light);
  border: 1px solid;
  border-radius: 5px;
  opacity: 0;
  transition: 0.2s;
}
.expand-button > svg {
  fill: var(--light);
  filter: contrast(0.3);
}
.expand-button:hover {
  cursor: pointer;
  border-color: var(--secondary);
}
.expand-button:focus {
  outline: 0;
}

pre:hover > .expand-button {
  opacity: 1;
  transition: 0.2s;
}

#mermaid-container {
  position: fixed;
  contain: layout;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: none;
  backdrop-filter: blur(4px);
  background: rgba(0, 0, 0, 0.5);
}
#mermaid-container.active {
  display: inline-block;
}
#mermaid-container > #mermaid-space {
  border: 1px solid var(--lightgray);
  background-color: var(--light);
  border-radius: 5px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: 80vh;
  width: 80vw;
  overflow: hidden;
}
#mermaid-container > #mermaid-space > .mermaid-content {
  padding: 2rem;
  position: relative;
  transform-origin: 0 0;
  transition: transform 0.1s ease;
  overflow: visible;
  min-height: 200px;
  min-width: 200px;
}
#mermaid-container > #mermaid-space > .mermaid-content pre {
  margin: 0;
  border: none;
}
#mermaid-container > #mermaid-space > .mermaid-content svg {
  max-width: none;
  height: auto;
}
#mermaid-container > #mermaid-space > .mermaid-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--light);
  border: 1px solid var(--lightgray);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid var(--lightgray);
  background: var(--light);
  color: var(--dark);
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  font-family: var(--bodyFont);
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:hover {
  background: var(--lightgray);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:active {
  transform: translateY(1px);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:nth-child(2) {
  width: auto;
  padding: 0 12px;
  font-size: 14px;
}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvaW0weDBpbmctYmxvZy1wcml2YXRlL2ltMHgwaW5nLWJsb2ctcHJpdmF0ZS9xdWFydHovY29tcG9uZW50cy9zdHlsZXMiLCJzb3VyY2VzIjpbIm1lcm1haWQuaW5saW5lLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7O0FBR0Y7RUFDRTtFQUNBOztBQUdGO0VBQ0U7OztBQUtGO0VBQ0U7RUFDQTs7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7O0FBR0Y7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFOztBQUdGO0VBQ0U7O0FBSUY7RUFDRTtFQUNBO0VBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhwYW5kLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nOiAwLjRyZW07XG4gIG1hcmdpbjogMC4zcmVtO1xuICByaWdodDogMDsgLy8gTk9URTogcmlnaHQgd2lsbCBiZSBzZXQgaW4gbWVybWFpZC5pbmxpbmUudHNcbiAgY29sb3I6IHZhcigtLWdyYXkpO1xuICBib3JkZXItY29sb3I6IHZhcigtLWRhcmspO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodCk7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuMnM7XG5cbiAgJiA+IHN2ZyB7XG4gICAgZmlsbDogdmFyKC0tbGlnaHQpO1xuICAgIGZpbHRlcjogY29udHJhc3QoMC4zKTtcbiAgfVxuXG4gICY6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXNlY29uZGFyeSk7XG4gIH1cblxuICAmOmZvY3VzIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG59XG5cbnByZSB7XG4gICY6aG92ZXIgPiAuZXhwYW5kLWJ1dHRvbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiAwLjJzO1xuICB9XG59XG5cbiNtZXJtYWlkLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgY29udGFpbjogbGF5b3V0O1xuICB6LWluZGV4OiA5OTk7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBkaXNwbGF5OiBub25lO1xuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuXG4gICYuYWN0aXZlIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAmID4gI21lcm1haWQtc3BhY2Uge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGhlaWdodDogODB2aDtcbiAgICB3aWR0aDogODB2dztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgJiA+IC5tZXJtYWlkLWNvbnRlbnQge1xuICAgICAgcGFkZGluZzogMnJlbTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgbWluLXdpZHRoOiAyMDBweDtcblxuICAgICAgcHJlIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIHN2ZyB7XG4gICAgICAgIG1heC13aWR0aDogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgfVxuICAgIH1cblxuICAgICYgPiAubWVybWFpZC1jb250cm9scyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDIwcHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDhweDtcbiAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWxpZ2h0KTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgICAgei1pbmRleDogMjtcblxuICAgICAgLm1lcm1haWQtY29udHJvbC1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHQpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZGFyayk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5Rm9udCk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0eWxlIHRoZSByZXNldCBidXR0b24gZGlmZmVyZW50bHlcbiAgICAgICAgJjpudGgtY2hpbGQoMikge1xuICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ== */</style><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" data-persist="true"/><script src="../../prescript.js" type="application/javascript" data-persist="true"></script><script type="application/javascript" data-persist="true">const fetchData = fetch("../../static/contentIndex.json").then(data => data.json())</script><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://im0x0ing.github.io/index.xml"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image" content="https://im0x0ing.github.io/课程笔记/操作系统/04.2-virtual-memory-og-image.webp"/><meta property="og:image:url" content="https://im0x0ing.github.io/课程笔记/操作系统/04.2-virtual-memory-og-image.webp"/><meta name="twitter:image" content="https://im0x0ing.github.io/课程笔记/操作系统/04.2-virtual-memory-og-image.webp"/><meta property="og:image:type" content="image/.webp"/></head><body data-slug="课程笔记/操作系统/04.2-virtual-memory"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="../..">ING wiki</a></h2><div class="spacer mobile-only"></div><div class="flex-component" style="flex-direction: row; flex-wrap: nowrap; gap: 1rem;"><div style="flex-grow: 1; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><div class="search"><button class="search-button"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg><p>Search</p></button><div class="search-container"><div class="search-space"><input autocomplete="off" class="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div class="search-layout" data-preview="true"></div></div></div></div></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="readermode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="readerIcon" fill="currentColor" stroke="currentColor" stroke-width="0.2" stroke-linecap="round" stroke-linejoin="round" width="64px" height="64px" viewBox="0 0 24 24" aria-label="Reader mode"><title>Reader mode</title><g transform="translate(-1.8, -1.8) scale(1.15, 1.2)"><path d="M8.9891247,2.5 C10.1384702,2.5 11.2209868,2.96705384 12.0049645,3.76669482 C12.7883914,2.96705384 13.8709081,2.5 15.0202536,2.5 L18.7549359,2.5 C19.1691495,2.5 19.5049359,2.83578644 19.5049359,3.25 L19.5046891,4.004 L21.2546891,4.00457396 C21.6343849,4.00457396 21.9481801,4.28672784 21.9978425,4.6528034 L22.0046891,4.75457396 L22.0046891,20.25 C22.0046891,20.6296958 21.7225353,20.943491 21.3564597,20.9931534 L21.2546891,21 L2.75468914,21 C2.37499337,21 2.06119817,20.7178461 2.01153575,20.3517706 L2.00468914,20.25 L2.00468914,4.75457396 C2.00468914,4.37487819 2.28684302,4.061083 2.65291858,4.01142057 L2.75468914,4.00457396 L4.50368914,4.004 L4.50444233,3.25 C4.50444233,2.87030423 4.78659621,2.55650904 5.15267177,2.50684662 L5.25444233,2.5 L8.9891247,2.5 Z M4.50368914,5.504 L3.50468914,5.504 L3.50468914,19.5 L10.9478955,19.4998273 C10.4513189,18.9207296 9.73864328,18.5588115 8.96709342,18.5065584 L8.77307039,18.5 L5.25444233,18.5 C4.87474657,18.5 4.56095137,18.2178461 4.51128895,17.8517706 L4.50444233,17.75 L4.50368914,5.504 Z M19.5049359,17.75 C19.5049359,18.1642136 19.1691495,18.5 18.7549359,18.5 L15.2363079,18.5 C14.3910149,18.5 13.5994408,18.8724714 13.0614828,19.4998273 L20.5046891,19.5 L20.5046891,5.504 L19.5046891,5.504 L19.5049359,17.75 Z M18.0059359,3.999 L15.0202536,4 L14.8259077,4.00692283 C13.9889509,4.06666544 13.2254227,4.50975805 12.7549359,5.212 L12.7549359,17.777 L12.7782651,17.7601316 C13.4923805,17.2719483 14.3447024,17 15.2363079,17 L18.0059359,16.999 L18.0056891,4.798 L18.0033792,4.75457396 L18.0056891,4.71 L18.0059359,3.999 Z M8.9891247,4 L6.00368914,3.999 L6.00599909,4.75457396 L6.00599909,4.75457396 L6.00368914,4.783 L6.00368914,16.999 L8.77307039,17 C9.57551536,17 10.3461406,17.2202781 11.0128313,17.6202194 L11.2536891,17.776 L11.2536891,5.211 C10.8200889,4.56369974 10.1361548,4.13636104 9.37521067,4.02745763 L9.18347055,4.00692283 L8.9891247,4 Z"></path></g></svg></button></div></div><div class="explorer" data-behavior="link" data-collapsed="collapsed" data-savestate="true" data-data-fns="{&quot;order&quot;:[&quot;filter&quot;,&quot;map&quot;,&quot;sort&quot;],&quot;sortFn&quot;:&quot;(a,b)=>!a.isFolder&amp;&amp;!b.isFolder||a.isFolder&amp;&amp;b.isFolder?a.displayName.localeCompare(b.displayName,void 0,{numeric:!0,sensitivity:\&quot;base\&quot;}):!a.isFolder&amp;&amp;b.isFolder?1:-1&quot;,&quot;filterFn&quot;:&quot;node=>node.slug===\&quot;\&quot;||node.slug.startsWith(\&quot;\\u8BFE\\u7A0B\\u7B14\\u8BB0\&quot;)&quot;,&quot;mapFn&quot;:&quot;node=>node&quot;}"><button type="button" class="explorer-toggle mobile-explorer hide-until-loaded" data-mobile="true" aria-controls="explorer-93"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" class="title-button explorer-toggle desktop-explorer" data-mobile="false" aria-expanded="true"><h2>Explorer</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-93" class="explorer-content" aria-expanded="false" role="group"><ul class="explorer-ul overflow" id="list-3"><li class="overflow-end"></li></ul></div><template id="template-file"><li><a href="#"></a></li></template><template id="template-folder"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div><button class="folder-button"><span class="folder-title"></span></button></div></div><div class="folder-outer"><ul class="content"></ul></div></li></template></div></div><div class="center"><div class="page-header"><header><nav class="my-navbar "><div class="links"><a href="/课程笔记/">课程笔记</a><a href="/技术积累/">技术积累</a><a href="/工具使用/">工具使用</a><a href="/生活杂谈/">生活杂谈</a></div></nav></header><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../课程笔记/">课程笔记</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../课程笔记/操作系统/">操作系统</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>04.2 virtual memory</a></div></nav><h1 class="article-title">04.2 virtual memory</h1><p show-comma="true" class="content-meta"><time datetime="2025-12-12T11:38:00.000Z">Dec 12, 2025</time><span>22 min read</span></p><ul class="tags"><li><a href="../../tags/flashcard" class="internal tag-link">flashcard</a></li></ul></div></div><article class="popover-hint"><p>DECK: CS::OS</p>
<h2 id="地址空间与异常">地址空间与异常<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#地址空间与异常" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><strong>地址空间 (address space)</strong> 指的是地址取值的全集。</p>
<ul>
<li><span class="text-highlight">物理地址空间</span>
<ul>
<li>例如，对于一个 32 位寻址的体系结构，其 <strong>物理地址空间</strong>（物理地址的集合）就是 ，亦即 <code>0x00000000 ~ 0xffffffff</code>。<br/>
- <strong>flat memory</strong>内存模型: 在引入分段 / 分页技术之前，各个进程和操作系统共同使用同一个物理地址空间。它会带来比较大的碎片，同时隔离性较差，内存的保护较弱。</li>
</ul>
</li>
<li><span class="text-highlight">虚拟地址空间</span>
<ul>
<li>而在引入了分段 / 分页技术之后，<span class="text-highlight">每个进程都有了自己的一套 logical memory (a.k.a. virtual memory)</span> ，其对应的的地址空间就叫做 <strong>逻辑地址空间 (logical address space)</strong> 或者 <strong>虚拟地址空间 (virtual address space)</strong>；而对应的段表 / 页表的作用就是<span class="text-highlight">提供从虚拟地址空间到物理地址空间的映射</span>（映射过程中，由于 swapping 机制的存在，也有可能出现 swap 的过程）。</li>
</ul>
</li>
<li>我们知道，上述的映射过程由 OS 和 MMU 共同实现，因此进程的虚拟地址空间是被隔离的；只要 MMU 不出现问题以及页表不被篡改（这通常比较困难），其他进程就没有办法访问到这个进程的内存。</li>
<li><span class="text-highlight">也就是说，虚拟内存供软件使用，而 CPU 在访问对应的内存地址时会由 MMU 自动转换为对应的物理地址；</span>如果对应的 page 不在物理内存中，就会触发一次 <strong>page fault</strong>，这是一个 exception。有 3 种可能的情况：
<ol>
<li>当前的进程的页表中<strong>并没有这个虚拟地址对应的 page</strong>；</li>
<li><strong>权限不符</strong>，例如试图运行某个权限位是 <code>RW-</code> 的 page 中的代码，或者试图写入某个权限位是 <code>R-X</code> 或 <code>R--</code> 的 page 中的某个内存单元；</li>
<li>当前虚拟地址是合法的，但是对应的 page 被 <strong>swapped out</strong> 了。</li>
</ol>
</li>
<li>我们知道，exception 会交由操作系统处理；如果是前两种情况，操作系统应当报错并做相关处理（例如杀掉对应进程）；而如果是后一种情况，操作系统应当将进程阻塞，并将对应的 page 交换回来，调页完成后唤醒进程。</li>
<li>在一条指令执行期间，可能触发多次 page fault（指令本身和访问的地址可能都不在物理内存中）。当 page fault 被解决后，指令被重新运行；因此一条指令在真正成功运行之前可能会被尝试运行多次。</li>
</ul>
<h3 id="kernel-addresses--userspace-addresses-flashcard">Kernel Addresses &amp; Userspace Addresses <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#kernel-addresses--userspace-addresses-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>每个进程的虚拟地址空间（下简称地址空间、AS）被分为了 <strong>Kernel Portion</strong> 和 <strong>User Portion</strong>
<ul>
<li>kernel 模式下的代码可以访问这两块空间 [CPU 陷入<strong>内核代码</strong>，进入高权限，但它依然是在<strong>这个进程</strong>的上下文中工作]</li>
<li>user 模式下的代码只能访问 User Portion。</li>
</ul>
</li>
<li>每个进程的 AS 的 kernel portion 都映射到了同一块物理内存。原因是显然的：所有进程用到的都是同一套 kernel，因此没必要把 kernel 用的内存（存例如各个进程的页表、各种队列之类的东西）复制好几份。</li>
</ul>
<h4 id="实现">实现<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#实现" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<ul>
<li>在 <span class="text-highlight">32 位虚拟地址空间</span>（4GB）的设计里，kernel 默认使用高 1GB，各个进程的 user portion 使用低 3GB 的虚拟地址空间；通过在 build kernel 之前更改 <code>CONFIG_PAGE_OFFSET</code> 可以更改这一分配
<ul>
<li>32位系统只使用一套页表<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251106144346.png" width="auto" height="auto" alt/></li>
</ul>
</li>
<li>对于 <span class="text-highlight">64 位虚拟地址空间</span>的设计，由于根本用不了这么多，因此 kernel space 和 user space 被自然分隔开：<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251106144355.png" width="450" height="auto" alt/>其中 <strong>TTBR (Translation Table Base Register)</strong> 保存页表的基地址</li>
<li>=<strong>TTBR0 管理的用户空间 + TTBR1 管理的内核空间</strong>。对应两套页表</li>
<li><strong>TTBR0</strong> 是每个进程的页表对应的 TTBR</li>
<li><strong>TTBR1</strong> 是 kernel portion 的页表对应的 TTBR。</li>
</ul>

<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>分配策略和置换策略的区别 </p></div>
                  
                </div>
<div class="callout-content">
<ul>
<li><strong>延迟分配</strong> 和 <strong>COW</strong> 是在内存<strong>充足时</strong>优化<strong>分配</strong>或<strong>复制</strong>的策略，目的是推迟或避免分配，从而节省内存。</li>
<li><strong>页面置换</strong> 是在内存<strong>不足时</strong>（物理帧耗尽）强制<strong>释放</strong>内存的策略，目的是在资源紧张时保证系统能继续运行。</li>
</ul>
</div>
</blockquote>
<h2 id="分配策略"><strong>分配策略</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分配策略" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="lazy-allocation--demand-paging-flashcard">Lazy Allocation / Demand Paging <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lazy-allocation--demand-paging-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>操作系统在分配 user space 的内存时，会使用 <span class="text-highlight">lazy allocation</span>：</p>
<ul>
<li>当用户程序申请一块内存时，操作系统并不会真的立即在物理内存中分配对应的内存；直到这块内存被真正访问。</li>
<li>原理: 很多用户程序申请的内存大小比真正需要使用的通常要大，例如 buffer 等。<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251106145215.png" width="auto" height="auto" alt/></li>
</ul>
<ol>
<li>程序（例如通过 <code>malloc</code> 库函数）发现需要更多内存，于是调用 <code>brk()</code> 系统调用来请求扩大其<strong>堆</strong>（Heap）的边界。
<ul>
<li>此时，虚拟堆大小为 8KB，物理内存占用（Rss - Resident Set Size）也是 8KB。</li>
</ul>
</li>
<li>内核响应 <code>brk()</code> 请求，仅仅扩大了进程的<strong>虚拟内存区域（VMA）</strong>。<span class="text-highlight">新的页面此时并未映射到任何物理内存</span>。
<ul>
<li>进程的虚拟堆大小（Size）增加到 16KB，但其物理内存占用（Rss）<strong>仍然是 8KB</strong>。内核只是在进程的虚拟地址空间中“画了一块饼”，但没有给它“真正的食物”（物理内存）。</li>
</ul>
</li>
<li>程序执行代码，试图<strong>第一次</strong>读取或写入刚刚申请到的新虚拟内存地址。
<ul>
<li>CPU（通过 MMU）在页表中查找该虚拟地址，发现它没有任何对应的物理内存映射。</li>
<li>处理器触发一个<strong>缺页中断（Page Fault）</strong>。这<strong>不是一个程序错误</strong>，而是一个给内核的信号。</li>
</ul>
</li>
<li>内核捕获这个中断，意识到这是一个合法的“按需分页”请求。<br/>
- 它从可用的“free”列表中找到一个空闲的<strong>物理页帧（Page Frame）</strong>。<br/>
- 内核将这个物理页帧<strong>映射</strong>到程序试图访问的虚拟地址。<br/>
- 它为此创建或更新<strong>页表项（PTE - Page Table Entry）</strong>。<br/>
- <strong>状态：</strong> 物理内存占用（Rss）现在增加到 12KB（假设新分配的页是 4KB）。</li>
</ol>

<h3 id="copy-on-write-flashcard">Copy-on-Write <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#copy-on-write-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>很多子进程在 <code>fork()</code> 之后立刻调用 <code>exec()</code><span class="orange-comment">[创建一个复制的子进程,并且用一个全新的程序(可执行文件)的内容覆盖内核态中父进程的代码、数据、栈和堆.]</span>因此将父进程的地址空间整个复制一份是比较浪费的明明马上就会被覆盖.</li>
<li>Copy-on-Write机制允许父进程和子进程最初使用同一份物理页来进行工作，在任何一个进程需要写入某个共享 frame 时再进行复制。<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251106145837.png" width="auto" height="auto" alt/><img src="../../课程笔记/操作系统/attachments/Pasted-image-20251106145841.png" width="auto" height="auto" alt/><br/>
进一步地，Linux 等操作系统提供了 <code>vfork()</code>，进一步优化子进程在 <code>fork()</code> 之后立刻调用 <code>exec()</code> 的情形。<code>vfork()</code> 并不使用 copy-on-write；调用 <code>vfork()</code> 之后，父进程会被挂起，子进程使用父进程的地址空间。如果子进程此时修改地址空间中的任何页面，这些修改对父进程都是可见的。</li>
</ul>

<h2 id="置换策略"><strong>置换策略</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#置换策略" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="page-replacement-flashcard">Page Replacement <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#page-replacement-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>我们在Lazy Allocation或者Copy-on-Write讨论的情况下，或者在 kernel、I/O buffer 之类的情况下,需要从磁盘将页调入内存,会需要空闲的物理帧<span class="orange-comment">[需要有一个位置]</span>.
<ul>
<li>但是没有空闲的物理帧时应该怎么办呢？我们可以交换出去一整个进程:
<ul>
<li>将一个进程的所有页都写回磁盘（备份存储），释放它占用的所有帧。</li>
</ul>
</li>
<li>更常见地，我们找到一个当前不在使用的帧，并释放它。<br/>
<span class="text-highlight">基本步骤是：</span></li>
</ul>
</li>
</ul>
<ol>
<li>找到这个 victim frame；</li>
<li>将其内容写回备份存储swap space/disk；
<ol>
<li> <strong>dirty bit (a.k.a. modify bit)</strong> 该位保存对应 frame 是否被修改过；如果没有被修改过,就不用写回</li>
</ol>
</li>
<li><strong>调入 Page X：</strong> 将进程 P 缺失的 Page <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 从硬盘（备份存储）<strong>调入</strong>到刚刚腾出的物理帧 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中。</li>
<li>修改页表（和 TLB 等）以表示它不在内存中了。
<ol>
<li>将页表中的有效位设置为无效</li>
<li>从TLB中删除对应条目<br/>
如何确定哪个 frame 应当用来作为 victim frame 呢？我们的核心目标是，降低 page fault 的频率。</li>
</ol>
</li>
</ol>

<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>如何从磁盘匹配和找回被换出的页面？ </p></div>
                  
                </div>
<div class="callout-content">
<p>被换出的页面总能被系统准确找回，这是因为<strong>页表</strong>和<strong>备份存储（Backing Store）<strong>有明确的记录机制。<br/>
当下次 CPU 再次请求访问这个</strong>已被换出</strong>的页面时，步骤如下：</p>
<ol>
<li><strong>触发缺页中断（Page Fault）：</strong> CPU 请求访问 Page <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，MMU 查阅该进程的页表。页表显示 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的 <strong>valid-invalid bit</strong> 设置为 <strong>无效（i）</strong>，触发 Page Fault，控制权交给 OS 内核。</li>
<li><strong>定位 Page <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>：</strong> OS 检查页表中的其他信息（这些信息在页被换出时被记录）
<ul>
<li><strong>页表项：</strong> 页表项不再存储帧号，而是存储一个<strong>特殊标记</strong>，该标记指向 Page <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 在**备份存储（磁盘）**上的确切位置（例如，交换空间中的块地址）。</li>
</ul>
</li>
<li><strong>调页（Paging）：</strong>
<ul>
<li>OS 执行<strong>页面置换</strong>流程（找到 Victim Frame）。</li>
<li>OS 从备份存储中，根据第 2 步记录的地址，<strong>将 Page <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 调入</strong>到这个 Victim Frame 中。</li>
</ul>
</li>
<li><strong>更新页表：</strong> Page <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 被调入后，OS 更新页表，将该页的 <code>valid-invalid bit</code> 设置为<strong>有效（v）</strong>，并记录它现在所处的<strong>物理帧号</strong>。</li>
<li><strong>指令重执行：</strong> OS 将控制权交还给 CPU，让 CPU 重新执行被中断的那条指令。</li>
</ol>
</div>
</blockquote>
<h4 id="页面置换算法-page-replacement-algorithms-flashcard">页面置换算法 (page replacement algorithms) <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#页面置换算法-page-replacement-algorithms-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<h5 id="optimal">Optimal<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#optimal" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<p>这种算法选择 <strong>最长时间内不再被访问的页面</strong> 换出。容易证明，这种方案的 page-fault rate 是最低的。不过，由于实际实现中我们没有办法预测结果，因此它只作为<span class="text-highlight">理论最优解</span>用来判定其他算法的优劣。</p>
<h5 id="fifo-first-in-first-out">FIFO (First In First Out)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#fifo-first-in-first-out" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<p>这种算法换出 <strong>最先进入内存的页面</strong>。实现比较简单，<span class="text-highlight">使用一个队列保存调入内存的顺序即可。</span><br/>
这种算法的问题是，其逻辑和实际不符；实际情况下有很多页面会经常被访问。<br/>
另外，这种算法可能会遇到物理帧增加的时候 page-fault 反而更多的异常情况。这被称为 <strong>Belady’s Anomaly</strong>：</p>
<ol>
<li>123412512345是一次请求访问的页面号
<ul>
<li>上半部分:限制进程只能使用 3 个帧。
<ul>
<li>关键页 A 可能会在它再次被访问<strong>之前</strong>就被淘汰了（FIFO 逻辑）。</li>
</ul>
</li>
<li>下半部分:限制进程可以使用 4 个帧。
<ul>
<li>由于内存变大，关键页 A 驻留的时间变长了。但与此同时，它占用的位置可能会导致另一个很快就要被用到的<strong>更关键的页 B</strong> 被提前淘汰，从而导致总体缺页次数增加<br/>
<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251113142050.png" width="auto" height="auto" alt/></li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="lru-least-recently-used">LRU (Least Recently Used)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lru-least-recently-used" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<ul>
<li>实现的一种策略是给每个页表项一个 counter，每次访问某个 page 时，将 counter 更新为<span class="text-highlight">当前的时间</span><span class="orange-comment">[只要被用了,就会往后调,从淘汰最早变成了淘汰间隔最长]</span>
<ul>
<li>每次需要置换时，搜索 counter 最小的页。也可以用 heap 来优化。</li>
</ul>
</li>
<li>另一种策略是用一个栈保存 page numbers，每次访问时找到它然后把它挪到栈顶。<br/>
这两种实现开销都比较大。</li>
</ul>
<h5 id="lru-approximation">LRU-Approximation<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lru-approximation" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<ul>
<li>因此，我们在 LRU 和性能之间做一个折中；引入一个 <strong>reference bit</strong>，来近似地实现 LRU。当一个 page 被访问时这个 bit 被置为 1；操作系统定期将 reference bit 清零。因此，在需要交换时，只需要找一个 reference bit 为 0 的就可以说明它在这段时间内没有被访问过。</li>
<li>或者加上优先级bit</li>
<li>加上counting bit 记录被访问的次数</li>
</ul>

<h2 id="进阶策略"><strong>进阶策略</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#进阶策略" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="allocation-of-frames">Allocation of Frames<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#allocation-of-frames" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<h4 id="为什么要分配frame">为什么要分配frame<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#为什么要分配frame" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<ul>
<li>
<p>采取 <strong>全局置换 (global replacement)</strong></p>
<ul>
<li>当进程 A 发生缺页中断需要一个新的帧时，操作系统可以从<strong>所有物理帧中</strong>（即系统中所有进程 P1, P2, P3… 占用的帧）中选取一个 Victim Frame<span class="orange-comment">[灵活:更好的系统吞吐量但是不隔离:自己的pagefault率会取决于其他进程的运行状况]</span></li>
<li>那么我们就不一定有必要提前规定每个进程最多能够使用多少个 frame；</li>
</ul>
</li>
<li>
<p>采取 <strong>局部替换 (local replacement)</strong><span class="orange-comment">[隔离但僵化]</span></p>
<ul>
<li>只在当前进程分配到的物理帧中进行替换</li>
<li>那么我们就需要提前把物理 frame 的资源分配给各个进程<span class="orange-comment">[要划分好区间不然就跟全局置换一样了]</span>。</li>
</ul>
</li>
<li>
<p>当我们需要决定一个进程能够使用的页面总数时，我们在上述最小和最大的区间内有非常多的选择，这就引入了分配算法。常见的分配算法包括平均分配，或者按进程对内存的实际需求按比例分配；也可以参考进程的优先级，高优先级相对分配到的更多，或者更能满足其实际需求。</p>
</li>
<li>
<p>现在的很多计算机都有多个 CPU，而每个 CPU 都可以比其他 CPU 更快地访问内存的某些部分。如果这种差异比较明显，我们称这种系统为 <strong>非均匀内存访问 (NUMA, Non-Uniform Memory Access)</strong> 系统。在这种系统下，为了更好的性能表现，前述的分配和调页算法可能更加复杂。</p>
</li>
</ul>
<h4 id="分配多少个-frames">分配多少个 Frames<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分配多少个-frames" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>给每个进程分配多少个 frame 呢？</p>
<ul>
<li>最大值不可能超过物理内存包含的 frame 总数</li>
<li>最小值是由具体的计算机架构决定的。[作系统只需要确保在执行<strong>任意一条指令</strong>时，该进程拥有足够的帧来容纳该指令涉及的所有页。因此最小值是最复杂的那条指令的帧]
<ul>
<li><span class="text-highlight">指令</span>在解决其涉及的全部 page fault 之后才能真正被运行<span class="orange-comment">[指令是原子操作,如果发生pagefault,cpu会暂停当前指令并进行中断处理]</span></li>
<li>因此每个进程分配的 frame 的最小值不应小于单个指令可能使用到的 frame 总数<span class="orange-comment">[允许指令运行,是最低要求,还会有其他帧来存储整个进程的代码\全局变量\堆\栈等等]</span>。一般情况如下
<ul>
<li>指令本身:1个page<span class="orange-comment">[指令会进行对齐]</span></li>
<li>两个访问内存的操作数，其中每个操作数访问的内存<span class="orange-comment">[可能]</span>跨越 2 个 page（即，这块数据在一个 page 的末尾和下一个 page 的开头）</li>
<li>那么这个架构上运行的进程的 minimum frame number 是 5。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="thrashing--flashcard">Thrashing  <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#thrashing--flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>如果一个进程可用的帧数量比较少（少于其频繁访问的页面数目），那么它会频繁出现 page fault；同一个 page 可能会被频繁地换入换出，以满足运行的要求。这种高度的页面调度活动成为称为 <strong>抖动 (thrashing)</strong>；其调页时间甚至会大于执行时间。</li>
<li><strong>工作集模型 (working set model)</strong> <span class="text-highlight">用来确定一个进程频繁访问的页面，保证这些页面不被换出；</span>需要调页时从剩余的页面进行交换。如果频繁访问的页面数已经大于了当前进程可用的页面数，操作系统就应当把整个进程换出，以防止出现抖动现象。</li>
</ul>

<h3 id="kernel-memory-allocation">Kernel Memory Allocation<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#kernel-memory-allocation" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>Kernel 中的很多数据结构大小<span class="text-highlight">区分比较大</span>，其中很多小于甚至远小于一个 page.因此，kernel 的设计应当尽可能节省内存，努力减少碎片。</li>
<li>尽可能减小 kernel 内存开销的考虑是：
<ul>
<li>一方面，kernel 有可能有一部分<span class="text-highlight">常驻在物理内存中</span>，不受调页系统的控制</li>
<li>另一方面，有的硬件设备可能和物理内存直接交互，因此可能会<span class="text-highlight">需要连续的物理内存</span>。</li>
<li>这两者对物理内存的要求都比较严格，因此我们应当尽可能减小这些开销。</li>
</ul>
</li>
</ul>
<h4 id="buddy-system-flashcard">Buddy System <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#buddy-system-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<ul>
<li>Buddy system 从物理连续的段上分配内存；每次分配内存大小是 <span class="text-highlight">2 的幂次方</span>，例如请求是 11KB，则分配 16KB。</li>
<li>当分配时，从物理段上切分出对应的大小，例如下图体现了分配 21KB 时的情况， 会被分配。<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251113142333.png" width="auto" height="auto" alt/><br/>
当它被释放时，会 <strong>合并 (coalesce)</strong> 相邻的块形成更大的块供之后使用。</li>
</ul>

<h4 id="slab-allocation-flashcard">Slab Allocation <a href="../.././../tags/flashcard" class="tag-link internal alias" data-slug="tags/flashcard">flashcard</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#slab-allocation-flashcard" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>核心的原理是，操作系统中很多 object 的大小是已知且固定的<span class="orange-comment">[PCB/socket buffers/PTE之类的]</span>。<span class="text-highlight">内存被划分成若干个固定大小的块，每个块都被分配给一个具体的类型</span>。当进程需要分配内存时，它会查询缓存，如果找到一个空闲的块，就直接使用该块；如果缓存中没有空闲的块，就会从系统内存中申请一个新的块：<br/>
<img src="../../课程笔记/操作系统/attachments/Pasted-image-20251113142340.png" width="auto" height="auto" alt/></p></article><hr/><div class="page-footer"><div class="giscus" data-repo="im0x0ing/im0x0ing.github.io" data-repo-id="R_kgDOQevgrA" data-category="Announcements" data-category-id="DIC_kwDOQevgrM4CzLI8" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-input-position="top" data-light-theme="light" data-dark-theme="dark" data-theme-url="https://im0x0ing.github.io/static/giscus" data-lang="zh-CN"></div></div></div><div class="right sidebar"><div class="toc desktop-only"><button type="button" class="toc-header" aria-controls="toc-38" aria-expanded="true"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div class="toc-depth-control"><span class="depth-label">H3</span><input type="range" class="depth-slider" min="1" max="6" value="2" step="1"/></div><ul id="list-9" class="toc-content overflow"><li class="depth-0"><a href="#地址空间与异常" data-for="地址空间与异常">地址空间与异常</a></li><li class="depth-1"><a href="#kernel-addresses--userspace-addresses-flashcard" data-for="kernel-addresses--userspace-addresses-flashcard">Kernel Addresses &amp; Userspace Addresses flashcard</a></li><li class="depth-2"><a href="#实现" data-for="实现">实现</a></li><li class="depth-0"><a href="#分配策略" data-for="分配策略">分配策略</a></li><li class="depth-1"><a href="#lazy-allocation--demand-paging-flashcard" data-for="lazy-allocation--demand-paging-flashcard">Lazy Allocation / Demand Paging flashcard</a></li><li class="depth-1"><a href="#copy-on-write-flashcard" data-for="copy-on-write-flashcard">Copy-on-Write flashcard</a></li><li class="depth-0"><a href="#置换策略" data-for="置换策略">置换策略</a></li><li class="depth-1"><a href="#page-replacement-flashcard" data-for="page-replacement-flashcard">Page Replacement flashcard</a></li><li class="depth-2"><a href="#页面置换算法-page-replacement-algorithms-flashcard" data-for="页面置换算法-page-replacement-algorithms-flashcard">页面置换算法 (page replacement algorithms) flashcard</a></li><li class="depth-3"><a href="#optimal" data-for="optimal">Optimal</a></li><li class="depth-3"><a href="#fifo-first-in-first-out" data-for="fifo-first-in-first-out">FIFO (First In First Out)</a></li><li class="depth-3"><a href="#lru-least-recently-used" data-for="lru-least-recently-used">LRU (Least Recently Used)</a></li><li class="depth-3"><a href="#lru-approximation" data-for="lru-approximation">LRU-Approximation</a></li><li class="depth-0"><a href="#进阶策略" data-for="进阶策略">进阶策略</a></li><li class="depth-1"><a href="#allocation-of-frames" data-for="allocation-of-frames">Allocation of Frames</a></li><li class="depth-2"><a href="#为什么要分配frame" data-for="为什么要分配frame">为什么要分配frame</a></li><li class="depth-2"><a href="#分配多少个-frames" data-for="分配多少个-frames">分配多少个 Frames</a></li><li class="depth-1"><a href="#thrashing--flashcard" data-for="thrashing--flashcard">Thrashing  flashcard</a></li><li class="depth-1"><a href="#kernel-memory-allocation" data-for="kernel-memory-allocation">Kernel Memory Allocation</a></li><li class="depth-2"><a href="#buddy-system-flashcard" data-for="buddy-system-flashcard">Buddy System flashcard</a></li><li class="depth-2"><a href="#slab-allocation-flashcard" data-for="slab-allocation-flashcard">Slab Allocation flashcard</a></li><li class="overflow-end"></li></ul></div><div class="backlinks"><h3>Backlinks</h3><ul id="list-10" class="overflow"><li><a href="../../课程笔记/操作系统/流程总览/01-系统启动与进程创建" class="internal">01 系统启动与进程创建</a></li><li><a href="../../课程笔记/操作系统/流程总览/02-内存管理" class="internal">02 内存管理</a></li><li><a href="../../课程笔记/操作系统/流程总览/04-完整流程示例" class="internal">04 完整流程示例</a></li><li><a href="../../课程笔记/操作系统/进程与内存流程总览" class="internal">进程与内存流程总览</a></li><li class="overflow-end"></li></ul></div><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div class="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button class="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div class="global-graph-outer"><div class="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.2,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.5.2</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript" data-persist="true">function n(){let t=this.parentElement;t.classList.toggle("is-collapsed");let e=t.getElementsByClassName("callout-content")[0];if(!e)return;let l=t.classList.contains("is-collapsed");e.style.gridTemplateRows=l?"0fr":"1fr"}function c(){let t=document.getElementsByClassName("callout is-collapsible");for(let e of t){let l=e.getElementsByClassName("callout-title")[0],s=e.getElementsByClassName("callout-content")[0];if(!l||!s)continue;l.addEventListener("click",n),window.addCleanup(()=>l.removeEventListener("click",n));let o=e.classList.contains("is-collapsed");s.style.gridTemplateRows=o?"0fr":"1fr"}}document.addEventListener("nav",c);
</script><script type="module" data-persist="true">function f(i,e){if(!i)return;function r(o){o.target===this&&(o.preventDefault(),o.stopPropagation(),e())}function t(o){o.key.startsWith("Esc")&&(o.preventDefault(),e())}i?.addEventListener("click",r),window.addCleanup(()=>i?.removeEventListener("click",r)),document.addEventListener("keydown",t),window.addCleanup(()=>document.removeEventListener("keydown",t))}function y(i){for(;i.firstChild;)i.removeChild(i.firstChild)}var h=class{constructor(e,r){this.container=e;this.content=r;this.setupEventListeners(),this.setupNavigationControls(),this.resetTransform()}isDragging=!1;startPan={x:0,y:0};currentPan={x:0,y:0};scale=1;MIN_SCALE=.5;MAX_SCALE=3;cleanups=[];setupEventListeners(){let e=this.onMouseDown.bind(this),r=this.onMouseMove.bind(this),t=this.onMouseUp.bind(this),o=this.resetTransform.bind(this);this.container.addEventListener("mousedown",e),document.addEventListener("mousemove",r),document.addEventListener("mouseup",t),window.addEventListener("resize",o),this.cleanups.push(()=>this.container.removeEventListener("mousedown",e),()=>document.removeEventListener("mousemove",r),()=>document.removeEventListener("mouseup",t),()=>window.removeEventListener("resize",o))}cleanup(){for(let e of this.cleanups)e()}setupNavigationControls(){let e=document.createElement("div");e.className="mermaid-controls";let r=this.createButton("+",()=>this.zoom(.1)),t=this.createButton("-",()=>this.zoom(-.1)),o=this.createButton("Reset",()=>this.resetTransform());e.appendChild(t),e.appendChild(o),e.appendChild(r),this.container.appendChild(e)}createButton(e,r){let t=document.createElement("button");return t.textContent=e,t.className="mermaid-control-button",t.addEventListener("click",r),window.addCleanup(()=>t.removeEventListener("click",r)),t}onMouseDown(e){e.button===0&&(this.isDragging=!0,this.startPan={x:e.clientX-this.currentPan.x,y:e.clientY-this.currentPan.y},this.container.style.cursor="grabbing")}onMouseMove(e){this.isDragging&&(e.preventDefault(),this.currentPan={x:e.clientX-this.startPan.x,y:e.clientY-this.startPan.y},this.updateTransform())}onMouseUp(){this.isDragging=!1,this.container.style.cursor="grab"}zoom(e){let r=Math.min(Math.max(this.scale+e,this.MIN_SCALE),this.MAX_SCALE),t=this.content.getBoundingClientRect(),o=t.width/2,n=t.height/2,c=r-this.scale;this.currentPan.x-=o*c,this.currentPan.y-=n*c,this.scale=r,this.updateTransform()}updateTransform(){this.content.style.transform=`translate(${this.currentPan.x}px, ${this.currentPan.y}px) scale(${this.scale})`}resetTransform(){this.scale=1;let e=this.content.querySelector("svg");this.currentPan={x:e.getBoundingClientRect().width/2,y:e.getBoundingClientRect().height/2},this.updateTransform()}},C=["--secondary","--tertiary","--gray","--light","--lightgray","--highlight","--dark","--darkgray","--codeFont"],E;document.addEventListener("nav",async()=>{let e=document.querySelector(".center").querySelectorAll("code.mermaid");if(e.length===0)return;E||=await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.esm.min.mjs");let r=E.default,t=new WeakMap;for(let n of e)t.set(n,n.innerText);async function o(){for(let s of e){s.removeAttribute("data-processed");let a=t.get(s);a&&(s.innerHTML=a)}let n=C.reduce((s,a)=>(s[a]=window.getComputedStyle(document.documentElement).getPropertyValue(a),s),{}),c=document.documentElement.getAttribute("saved-theme")==="dark";r.initialize({startOnLoad:!1,securityLevel:"loose",theme:c?"dark":"base",themeVariables:{fontFamily:n["--codeFont"],primaryColor:n["--light"],primaryTextColor:n["--darkgray"],primaryBorderColor:n["--tertiary"],lineColor:n["--darkgray"],secondaryColor:n["--secondary"],tertiaryColor:n["--tertiary"],clusterBkg:n["--light"],edgeLabelBackground:n["--highlight"]}}),await r.run({nodes:e})}await o(),document.addEventListener("themechange",o),window.addCleanup(()=>document.removeEventListener("themechange",o));for(let n=0;n<e.length;n++){let v=function(){let g=l.querySelector("#mermaid-space"),m=l.querySelector(".mermaid-content");if(!m)return;y(m);let w=c.querySelector("svg").cloneNode(!0);m.appendChild(w),l.classList.add("active"),g.style.cursor="grab",u=new h(g,m)},M=function(){l.classList.remove("active"),u?.cleanup(),u=null},c=e[n],s=c.parentElement,a=s.querySelector(".clipboard-button"),d=s.querySelector(".expand-button"),p=window.getComputedStyle(a),L=a.offsetWidth+parseFloat(p.marginLeft||"0")+parseFloat(p.marginRight||"0");d.style.right=`calc(${L}px + 0.3rem)`,s.prepend(d);let l=s.querySelector("#mermaid-container");if(!l)return;let u=null;d.addEventListener("click",v),f(l,M),window.addCleanup(()=>{u?.cleanup(),d.removeEventListener("click",v)})}});
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript" data-persist="true"></script><script src="../../postscript.js" type="module" data-persist="true"></script></html>