<!DOCTYPE html>
<html lang="en" dir="ltr"><head><title>传输层 Transport Layer</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto Sans SC:wght@400;700&amp;family=Noto Serif SC:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700;1,900&amp;family=JetBrains Mono:wght@400;600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="ING wiki"/><meta property="og:title" content="传输层 Transport Layer"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="传输层 Transport Layer"/><meta name="twitter:description" content="传输层的功能 传输层提供端到端的通信；也提供面向连接和无连接的两种服务。 也有观点认为，网络层提供的并不是真正的端到端（即，进程到进程）的服务，而只是主机到主机的服务，因为它并没有办法找到目标的进程。 但传输层通过端口来标识应用进程，从而真正实现进程之间的通信。 在网络层已经有了面向连接和无连接的两种通信方式的情况下，为什么传输层还要提供这两种服务呢？ 因为网络层提供的服务更多是由 ISP 决定的；主要运行在路由器上 但传输层的代码运行在用户自己的机器上，因此用户可以在这一层选择协议来提高网络的服务质量。 传输层是面向通信部分的最高层，起着承上启下的作用。每个传输服务会给用户提供一组接口，用户..."/><meta property="og:description" content="传输层的功能 传输层提供端到端的通信；也提供面向连接和无连接的两种服务。 也有观点认为，网络层提供的并不是真正的端到端（即，进程到进程）的服务，而只是主机到主机的服务，因为它并没有办法找到目标的进程。 但传输层通过端口来标识应用进程，从而真正实现进程之间的通信。 在网络层已经有了面向连接和无连接的两种通信方式的情况下，为什么传输层还要提供这两种服务呢？ 因为网络层提供的服务更多是由 ISP 决定的；主要运行在路由器上 但传输层的代码运行在用户自己的机器上，因此用户可以在这一层选择协议来提高网络的服务质量。 传输层是面向通信部分的最高层，起着承上启下的作用。每个传输服务会给用户提供一组接口，用户..."/><meta property="og:image:alt" content="传输层的功能 传输层提供端到端的通信；也提供面向连接和无连接的两种服务。 也有观点认为，网络层提供的并不是真正的端到端（即，进程到进程）的服务，而只是主机到主机的服务，因为它并没有办法找到目标的进程。 但传输层通过端口来标识应用进程，从而真正实现进程之间的通信。 在网络层已经有了面向连接和无连接的两种通信方式的情况下，为什么传输层还要提供这两种服务呢？ 因为网络层提供的服务更多是由 ISP 决定的；主要运行在路由器上 但传输层的代码运行在用户自己的机器上，因此用户可以在这一层选择协议来提高网络的服务质量。 传输层是面向通信部分的最高层，起着承上启下的作用。每个传输服务会给用户提供一组接口，用户..."/><meta property="twitter:domain" content="im0x0ing.github.io"/><meta property="og:url" content="https://im0x0ing.github.io/课程笔记/计算机网络/06-传输层-Transport-Layer"/><meta property="twitter:url" content="https://im0x0ing.github.io/课程笔记/计算机网络/06-传输层-Transport-Layer"/><link rel="icon" href="../../static/icon.png"/><meta name="description" content="传输层的功能 传输层提供端到端的通信；也提供面向连接和无连接的两种服务。 也有观点认为，网络层提供的并不是真正的端到端（即，进程到进程）的服务，而只是主机到主机的服务，因为它并没有办法找到目标的进程。 但传输层通过端口来标识应用进程，从而真正实现进程之间的通信。 在网络层已经有了面向连接和无连接的两种通信方式的情况下，为什么传输层还要提供这两种服务呢？ 因为网络层提供的服务更多是由 ISP 决定的；主要运行在路由器上 但传输层的代码运行在用户自己的机器上，因此用户可以在这一层选择协议来提高网络的服务质量。 传输层是面向通信部分的最高层，起着承上启下的作用。每个传输服务会给用户提供一组接口，用户..."/><meta name="generator" content="Quartz"/><link href="../../index.css" rel="stylesheet" type="text/css" data-persist="true"/><style>.expand-button {
  position: absolute;
  display: flex;
  float: right;
  padding: 0.4rem;
  margin: 0.3rem;
  right: 0;
  color: var(--gray);
  border-color: var(--dark);
  background-color: var(--light);
  border: 1px solid;
  border-radius: 5px;
  opacity: 0;
  transition: 0.2s;
}
.expand-button > svg {
  fill: var(--light);
  filter: contrast(0.3);
}
.expand-button:hover {
  cursor: pointer;
  border-color: var(--secondary);
}
.expand-button:focus {
  outline: 0;
}

pre:hover > .expand-button {
  opacity: 1;
  transition: 0.2s;
}

#mermaid-container {
  position: fixed;
  contain: layout;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: none;
  backdrop-filter: blur(4px);
  background: rgba(0, 0, 0, 0.5);
}
#mermaid-container.active {
  display: inline-block;
}
#mermaid-container > #mermaid-space {
  border: 1px solid var(--lightgray);
  background-color: var(--light);
  border-radius: 5px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: 80vh;
  width: 80vw;
  overflow: hidden;
}
#mermaid-container > #mermaid-space > .mermaid-content {
  padding: 2rem;
  position: relative;
  transform-origin: 0 0;
  transition: transform 0.1s ease;
  overflow: visible;
  min-height: 200px;
  min-width: 200px;
}
#mermaid-container > #mermaid-space > .mermaid-content pre {
  margin: 0;
  border: none;
}
#mermaid-container > #mermaid-space > .mermaid-content svg {
  max-width: none;
  height: auto;
}
#mermaid-container > #mermaid-space > .mermaid-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--light);
  border: 1px solid var(--lightgray);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid var(--lightgray);
  background: var(--light);
  color: var(--dark);
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  font-family: var(--bodyFont);
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:hover {
  background: var(--lightgray);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:active {
  transform: translateY(1px);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:nth-child(2) {
  width: auto;
  padding: 0 12px;
  font-size: 14px;
}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvaW0weDBpbmctYmxvZy1wcml2YXRlL2ltMHgwaW5nLWJsb2ctcHJpdmF0ZS9xdWFydHovY29tcG9uZW50cy9zdHlsZXMiLCJzb3VyY2VzIjpbIm1lcm1haWQuaW5saW5lLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7O0FBR0Y7RUFDRTtFQUNBOztBQUdGO0VBQ0U7OztBQUtGO0VBQ0U7RUFDQTs7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7O0FBR0Y7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFOztBQUdGO0VBQ0U7O0FBSUY7RUFDRTtFQUNBO0VBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhwYW5kLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nOiAwLjRyZW07XG4gIG1hcmdpbjogMC4zcmVtO1xuICByaWdodDogMDsgLy8gTk9URTogcmlnaHQgd2lsbCBiZSBzZXQgaW4gbWVybWFpZC5pbmxpbmUudHNcbiAgY29sb3I6IHZhcigtLWdyYXkpO1xuICBib3JkZXItY29sb3I6IHZhcigtLWRhcmspO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodCk7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuMnM7XG5cbiAgJiA+IHN2ZyB7XG4gICAgZmlsbDogdmFyKC0tbGlnaHQpO1xuICAgIGZpbHRlcjogY29udHJhc3QoMC4zKTtcbiAgfVxuXG4gICY6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXNlY29uZGFyeSk7XG4gIH1cblxuICAmOmZvY3VzIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG59XG5cbnByZSB7XG4gICY6aG92ZXIgPiAuZXhwYW5kLWJ1dHRvbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiAwLjJzO1xuICB9XG59XG5cbiNtZXJtYWlkLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgY29udGFpbjogbGF5b3V0O1xuICB6LWluZGV4OiA5OTk7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBkaXNwbGF5OiBub25lO1xuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuXG4gICYuYWN0aXZlIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAmID4gI21lcm1haWQtc3BhY2Uge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGhlaWdodDogODB2aDtcbiAgICB3aWR0aDogODB2dztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgJiA+IC5tZXJtYWlkLWNvbnRlbnQge1xuICAgICAgcGFkZGluZzogMnJlbTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgbWluLXdpZHRoOiAyMDBweDtcblxuICAgICAgcHJlIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIHN2ZyB7XG4gICAgICAgIG1heC13aWR0aDogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgfVxuICAgIH1cblxuICAgICYgPiAubWVybWFpZC1jb250cm9scyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDIwcHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDhweDtcbiAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWxpZ2h0KTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgICAgei1pbmRleDogMjtcblxuICAgICAgLm1lcm1haWQtY29udHJvbC1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHQpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZGFyayk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5Rm9udCk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0eWxlIHRoZSByZXNldCBidXR0b24gZGlmZmVyZW50bHlcbiAgICAgICAgJjpudGgtY2hpbGQoMikge1xuICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ== */</style><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" data-persist="true"/><script src="../../prescript.js" type="application/javascript" data-persist="true"></script><script type="application/javascript" data-persist="true">const fetchData = fetch("../../static/contentIndex.json").then(data => data.json())</script><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://im0x0ing.github.io/index.xml"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image" content="https://im0x0ing.github.io/课程笔记/计算机网络/06-传输层-Transport-Layer-og-image.webp"/><meta property="og:image:url" content="https://im0x0ing.github.io/课程笔记/计算机网络/06-传输层-Transport-Layer-og-image.webp"/><meta name="twitter:image" content="https://im0x0ing.github.io/课程笔记/计算机网络/06-传输层-Transport-Layer-og-image.webp"/><meta property="og:image:type" content="image/.webp"/></head><body data-slug="课程笔记/计算机网络/06-传输层-Transport-Layer"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="../..">ING wiki</a></h2><div class="spacer mobile-only"></div><div class="flex-component" style="flex-direction: row; flex-wrap: nowrap; gap: 1rem;"><div style="flex-grow: 1; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><div class="search"><button class="search-button"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg><p>Search</p></button><div class="search-container"><div class="search-space"><input autocomplete="off" class="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div class="search-layout" data-preview="true"></div></div></div></div></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="readermode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="readerIcon" fill="currentColor" stroke="currentColor" stroke-width="0.2" stroke-linecap="round" stroke-linejoin="round" width="64px" height="64px" viewBox="0 0 24 24" aria-label="Reader mode"><title>Reader mode</title><g transform="translate(-1.8, -1.8) scale(1.15, 1.2)"><path d="M8.9891247,2.5 C10.1384702,2.5 11.2209868,2.96705384 12.0049645,3.76669482 C12.7883914,2.96705384 13.8709081,2.5 15.0202536,2.5 L18.7549359,2.5 C19.1691495,2.5 19.5049359,2.83578644 19.5049359,3.25 L19.5046891,4.004 L21.2546891,4.00457396 C21.6343849,4.00457396 21.9481801,4.28672784 21.9978425,4.6528034 L22.0046891,4.75457396 L22.0046891,20.25 C22.0046891,20.6296958 21.7225353,20.943491 21.3564597,20.9931534 L21.2546891,21 L2.75468914,21 C2.37499337,21 2.06119817,20.7178461 2.01153575,20.3517706 L2.00468914,20.25 L2.00468914,4.75457396 C2.00468914,4.37487819 2.28684302,4.061083 2.65291858,4.01142057 L2.75468914,4.00457396 L4.50368914,4.004 L4.50444233,3.25 C4.50444233,2.87030423 4.78659621,2.55650904 5.15267177,2.50684662 L5.25444233,2.5 L8.9891247,2.5 Z M4.50368914,5.504 L3.50468914,5.504 L3.50468914,19.5 L10.9478955,19.4998273 C10.4513189,18.9207296 9.73864328,18.5588115 8.96709342,18.5065584 L8.77307039,18.5 L5.25444233,18.5 C4.87474657,18.5 4.56095137,18.2178461 4.51128895,17.8517706 L4.50444233,17.75 L4.50368914,5.504 Z M19.5049359,17.75 C19.5049359,18.1642136 19.1691495,18.5 18.7549359,18.5 L15.2363079,18.5 C14.3910149,18.5 13.5994408,18.8724714 13.0614828,19.4998273 L20.5046891,19.5 L20.5046891,5.504 L19.5046891,5.504 L19.5049359,17.75 Z M18.0059359,3.999 L15.0202536,4 L14.8259077,4.00692283 C13.9889509,4.06666544 13.2254227,4.50975805 12.7549359,5.212 L12.7549359,17.777 L12.7782651,17.7601316 C13.4923805,17.2719483 14.3447024,17 15.2363079,17 L18.0059359,16.999 L18.0056891,4.798 L18.0033792,4.75457396 L18.0056891,4.71 L18.0059359,3.999 Z M8.9891247,4 L6.00368914,3.999 L6.00599909,4.75457396 L6.00599909,4.75457396 L6.00368914,4.783 L6.00368914,16.999 L8.77307039,17 C9.57551536,17 10.3461406,17.2202781 11.0128313,17.6202194 L11.2536891,17.776 L11.2536891,5.211 C10.8200889,4.56369974 10.1361548,4.13636104 9.37521067,4.02745763 L9.18347055,4.00692283 L8.9891247,4 Z"></path></g></svg></button></div></div><div class="explorer" data-behavior="link" data-collapsed="collapsed" data-savestate="true" data-data-fns="{&quot;order&quot;:[&quot;filter&quot;,&quot;map&quot;,&quot;sort&quot;],&quot;sortFn&quot;:&quot;(a,b)=>!a.isFolder&amp;&amp;!b.isFolder||a.isFolder&amp;&amp;b.isFolder?a.displayName.localeCompare(b.displayName,void 0,{numeric:!0,sensitivity:\&quot;base\&quot;}):!a.isFolder&amp;&amp;b.isFolder?1:-1&quot;,&quot;filterFn&quot;:&quot;node=>node.slug===\&quot;\&quot;||node.slug.startsWith(\&quot;\\u8BFE\\u7A0B\\u7B14\\u8BB0\&quot;)&quot;,&quot;mapFn&quot;:&quot;node=>node&quot;}"><button type="button" class="explorer-toggle mobile-explorer hide-until-loaded" data-mobile="true" aria-controls="explorer-166"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" class="title-button explorer-toggle desktop-explorer" data-mobile="false" aria-expanded="true"><h2>Explorer</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-166" class="explorer-content" aria-expanded="false" role="group"><ul class="explorer-ul overflow" id="list-3"><li class="overflow-end"></li></ul></div><template id="template-file"><li><a href="#"></a></li></template><template id="template-folder"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div><button class="folder-button"><span class="folder-title"></span></button></div></div><div class="folder-outer"><ul class="content"></ul></div></li></template></div></div><div class="center"><div class="page-header"><header><nav class="my-navbar "><div class="links"><a href="/课程笔记/">课程笔记</a><a href="/技术积累/">技术积累</a><a href="/工具使用/">工具使用</a><a href="/生活杂谈/">生活杂谈</a></div></nav></header><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../课程笔记/">课程笔记</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../课程笔记/计算机网络/">计算机网络</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>传输层 Transport Layer</a></div></nav><h1 class="article-title">传输层 Transport Layer</h1><p show-comma="true" class="content-meta"><time datetime="2026-01-14T16:37:00.000Z">Jan 14, 2026</time><span>33 min read</span></p><ul class="tags"><li><a href="../../tags/待解决" class="internal tag-link">待解决</a></li></ul></div></div><article class="popover-hint"><h3 id="传输层的功能">传输层的功能<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#传输层的功能" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>传输层提供端到端的通信；也提供面向连接和无连接的两种服务。</li>
<li>也有观点认为，<strong>网络层</strong>提供的并不是真正的端到端（即，进程到进程）的服务，而只是<span class="text-highlight">主机到主机的服务</span>，因为它并没有办法找到目标的进程。<br/>
但<strong>传输层</strong>通过<span class="text-highlight">端口</span>来标识应用进程，从而真正实现进程之间的通信。</li>
</ul>
<p>在网络层已经有了面向连接和无连接的两种通信方式的情况下，为什么传输层还要提供这两种服务呢？</p>
<ul>
<li>因为网络层提供的服务更多是由 ISP 决定的；主要运行在路由器上</li>
<li>但传输层的代码运行在<span class="text-highlight">用户自己的机器上</span>，因此用户可以在这一层选择协议来提高网络的服务质量。</li>
</ul>
<p>传输层是面向通信部分的最高层，起着承上启下的作用。每个传输服务会给用户提供一组接口，用户（或者说应用）只需要调用这些接口就能调用相应的功能了。传输服务之于网络服务就像编程语言之于汇编语言：<strong>当切换不同的网络服务时，只需要切换一种传输服务到网络服务的库就好了</strong>；就像在新的架构上运行原来的 C 语言程序时，只需要换一个编译器就好。同时，网络服务就像汇编语言一样被用的比较少；但传输服务就像高级语言一样会被很多程序员使用。因此，传输服务的接口一定要更加方便、简单。</p>
<p>怎么实现端到端的通信呢？SAP: Service Access Point. Transport SAP 即 Port，用来指定进程，有 16bit，可以表示 65536 个不同的端口号。</p>
<p>传输层传输的单位称为 segment。<br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125100653.png" width="auto" height="auto" alt/></p>
<h3 id="udp">UDP<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#udp" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>UDP, User Datagram Protocol 是一个<span class="text-highlight">无连接的非可靠传输层协议</span>。<br/>
它在 IP 之上只提供 2 个附加服务：</p>
<ul>
<li>多路复用</li>
<li>对数据的错误检查（IP 只检查头部的错误）。</li>
</ul>
<blockquote>
<p>它不进行流量控制、拥塞控制和重传，所有维护可靠性的工作由应用层完成；它只是提供一个与 IP 协议的接口。</p>
</blockquote>
<ul>
<li>
<p><strong>UDP length</strong> 是包含 <span class="text-highlight">UDP Header (8 Bytes) 和数据在内</span>的总字节数。最小是 8，即只有头部；最大是 65515，这是 IP 的限制。</p>
</li>
<li>
<p><strong>UDP checksum</strong> 是可选的；如果不想检查就写全 0。其算法与 IP checksum 类似，具体参与运算的包含一个 12 Bytes 的 IPv4 pseudoheader、UDP checksum 暂时置零的 UDP header 以及数据部分。</p>
<ul>
<li>如果数据部分的长度不是 16 bits 的整倍数，则在末尾补 0 用于计算；但补的 0 不会被发送出去。</li>
</ul>
</li>
<li>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/641515/1638284948194-1efa3cef-1bbc-4cb6-a7dc-7c512371d90d.jpeg" alt/></p>
<ul>
<li>首部<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125100952.png" width="auto" height="auto" alt/></li>
<li>伪首部<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125101317.png" width="auto" height="auto" alt/></li>
<li></li>
</ul>
</li>
<li>
<p>其中，IPv4 pseudoheader 中的长度是和 UDP header 中的长度一致的。同时也可以看到，<span class="text-highlight">UDP 在计算时是用到了发送方和接收方的 IPv4 地址的；这有违分层原则</span>。当然，pseudoheader 也有对应的 IPv6 版本。</p>
</li>
</ul>
<p>UDP 适合一次性传输较少数据的网络应用，也适合那些可靠性不那么重要但不能容忍延迟的<strong>应用</strong>。</p>
<ul>
<li>DNS域名系统</li>
<li>SSDP简单服务发现协议</li>
</ul>
<h5 id="rtp-实时传输协议不怎么考">RTP 实时传输协议<span class="orange-comment">[不怎么考]</span><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#rtp-实时传输协议不怎么考" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<ul>
<li>RFC3550</li>
<li>它是一种传输协议，只是碰巧在应用层实现
<ul>
<li>以数据包形式传输音频和视频
<ul>
<li>将多个实时数据流复用到单个 UDP 数据包流中。UDP 流可以发送到单个目的地（单播）或多个目的地（多播）。</li>
</ul>
</li>
<li>接收方在正确的时间播放音频和视频</li>
</ul>
</li>
<li>不保证传递，数据包可能会丢失、延迟、损坏等。RTP 流中发送的每个数据包的编号都比其前驱数据包高一个
<ul>
<li>目的地确定有数据包丢失,可以跳过（视频帧）或插值（音频数据）<span class="orange-comment">[没有确认机制]</span></li>
</ul>
</li>
<li>每个 RTP 负载可能包含多个样本，它们可以按应用程序需要的任何方式进行编码。提供一个头字段来指定编码方.</li>
<li>为每个数据包中的第一个样本关联一个时间戳。这个机制允许目的端进行少量缓冲，并在流开始后的正确毫秒数后播放每个样本。
<ul>
<li>减少网络延迟变化的影响</li>
<li>同步多个流<br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125102720.png" width="auto" height="auto" alt/></li>
</ul>
</li>
<li>3个32bits 以及一些可能的扩展</li>
</ul>
<h5 id="rtcp-实时传输控制协议">RTCP 实时传输控制协议<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#rtcp-实时传输控制协议" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<p>RTP的配套协议</p>
<ul>
<li>用于处理反馈\同步和用户界面</li>
<li>不传输任何媒体样本</li>
</ul>
<h3 id="tcp">TCP<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>TCP, Transmission Control Protocol 是为了在<span class="text-highlight">不可靠的 IP 层</span>上实现可靠端到端传输设计的。<br/>
它是面向连接的，且只支持一对一的通信（而 UDP 支持一对多、多对一、多对多），提供<span class="text-highlight">全双工点到点</span>通信，解决传输的可靠、有序、无丢失、不重复。</p>
<ul>
<li><strong>TCP 是面向字节流的，而 UDP 是面向报文的</strong>。这就是说，UDP Segment 的长度由应用程序传来的数据决定，而 TCP 只将应用程序传来的数据视为无结构的字节流，segment 的长度由协议<span class="text-highlight">动态决定</span>。</li>
<li>设计宗旨是动态适应互联网的特性<span class="orange-comment">[差异很大的拓扑、带宽、延迟、数据包大小和其他参数]</span>，并在面对多种故障时具有强大的鲁棒性。</li>
</ul>
<p>主要的:RFC2018/2581/3168<br/>
基本TCP协议:具有动态窗口大小的滑动窗口协议</p>
<p>TCP 服务是由发送方和接收方创建的端点（称为sockets）获得的。</p>
<ul>
<li>Each socket has a socket number (address) consisting of<br/>
the IP addressing of the host and a 16-bit number local to<br/>
that host, called a port<br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125104001.png" width="auto" height="auto" alt/></li>
<li>Connections are identified by the socket identifiers at both<br/>
ends, that is, (socket1, socket2)</li>
</ul>
<h4 id="tcp-segment"><strong>TCP Segment</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp-segment" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>限制segent大小的两个条件</p>
<ul>
<li>每个段包括头部必须适配65515字节ip负载(65535-20IP头)</li>
<li>每个链路都有一个MTU最大传输单元</li>
</ul>
<p><strong>TCP 的一个关键特性，也是主导该协议设计的特性，是 TCP 连接上的每个字节都有自己的 32 位序列号。</strong></p>
<ul>
<li>序列号空间是基于字节的，而不是基于段的</li>
<li>没有任何数据的段是合法的，通常用于确认和控制消息。<br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125105053.png" width="auto" height="auto" alt/></li>
<li>source port和destination port 连接识别器是一个五元组,包括协议<span class="orange-comment">[TCP]</span>\源ip\源端口\目的ip\目的端口</li>
<li>Sequence number - 4B
<ul>
<li>TCP 是面向字节流的，因此它的 seq# 是以字节计数的。例如一个 segment 的 seq# 是 301，数据长度是 100B，那么这个 segment 就包含了第 301~400 个字节，下一个 segment 的 seq# 就是 401。</li>
</ul>
</li>
<li>Ack number - 4B
<ul>
<li><strong>期望收到的</strong>下一个 segment 的 seq#。例如收到了上面说的那个 segment，那发回去的 segment 的 ack# 就应该是 401。</li>
<li>是一个cumulatie acknowledgement累积确认,因为用一个数字概括了接收到的数据
<ul>
<li>Carries highest in-order sequence number</li>
<li>Normally a steady advance</li>
</ul>
</li>
</ul>
</li>
<li>TCP header length - 4bits
<ul>
<li>以 32 bits / 4 Bytes 计数。由于 header 有变长的 offset 字段，因此 header 的长度也是可变的。这一字段也被称作 data offset，因为它作为 header 的长度同时也表示了 segment 中的数据是从哪里开始的；这个 offset 与 IP datagram fragments 中的 offset 不一样。<span class="orange-comment">[里面是字的length 比如8字,实际上就是8*4=32Bytes]</span></li>
</ul>
</li>
<li>Reserved - 4bits
<ul>
<li>设计时用于在发现协议出现设计问题后补充使用；本来有 6 位，只用掉了 2 位，说明设计的不错。目前应当置 0。</li>
</ul>
</li>
<li><strong>CWR</strong>, Congestion Window Reduced; <strong>ECE</strong> - Explicit Congestion Notification Echo：
<ul>
<li>当 TCP 接收端得知网络拥塞<span class="orange-comment">[表现为丢包]</span>后，就设置 ECN-Echo (ECE) 从而显式告知发送端网络拥塞，需要放慢发送速率；</li>
<li>当 TCP 发送端收到 ECE 后就设置 CWR 从而告诉接收端已经放慢速率了，不需要再发 ECE 了<span class="orange-comment">[一直发送直到接收到CWR已被设置为止]</span>。</li>
</ul>
</li>
<li><strong>URG</strong>, URGent bit。
<ul>
<li>可以看到后面还有一个 16 bits 的 Urgent pointer 字段，只有在 URG = 1 时该字段才有效。此时表示该 segment 中有紧急数据，紧急指针用于指示从当前序列号<span class="orange-comment">[字节流]</span>开始的字节偏移量，紧急数据位于该位置范围。
<ul>
<li>例如，假设当前序列号为 1000，如果紧急指针=10，那么此字节流中紧急数据的端点是 1000+10=1010</li>
</ul>
</li>
<li>当紧急数据在目的地被接收时，接收应用程序会被中断，以便它可以停止正在进行的任何操作，读取数据流以查找紧急数据。</li>
<li>紧急数据的结尾被标记，以便应用程序知道何时结束。紧急数据的开始没有被标记。应用程序需要自己判断。</li>
</ul>
</li>
<li><strong>ACK</strong>。
<ul>
<li>ACK = 1 时 ack# 字段才有效,=0时确认字号字段会被忽略。TCP 规定建立连接后所有 segment 的 ACK 都是 1。</li>
</ul>
</li>
<li><strong>PSH</strong>, push。
<ul>
<li>PSH = 1 表示接收端在接收到 segment 后应当尽快交付给应用程序，而并不是等到缓冲区满后再向上交付。</li>
</ul>
</li>
<li><strong>RST</strong>, reset。
<ul>
<li>RST = 1 表示 TCP 连接中发生严重差错，例如主机崩溃等，需要重置连接。也用于拒绝无效段或拒绝尝试建立连接</li>
</ul>
</li>
<li><strong>SYN</strong>, synchronize。
<ul>
<li>SYN = 1 表示<span class="text-highlight">这是一个连接请求或者连接接受 segment</span>。
<ul>
<li>SYN = 1, ACK = 0<span class="orange-comment">[表示32位ack没有意义]</span> 说明这是一个连接request segment</li>
<li>SYN = 1, ACK = 1 说明这是一个连接reply segment。</li>
</ul>
</li>
</ul>
</li>
<li><strong>FIN</strong>, finish。
<ul>
<li>FIN = 1 表示发送方数据已经发送完毕，要求释放传输连接。SYN和FIN的segment都会有序列号,因此能够保证以正确的顺序进行处理</li>
</ul>
</li>
<li>Window size，2 Byte
<ul>
<li>表示允许对方发送的数据量（TCP 是全双工的）。例如 ack# 是 701，window size 是 1000，就说明允许对方发送 701~1700 这些字节。
<ul>
<li>Window size 可以为 0，表示现在不想要；</li>
<li>之后想要恢复时只需要发送一个同样 ack# 但是 window size 不为 0 的 segment 就行了。</li>
</ul>
</li>
</ul>
</li>
<li>Checksum，2 Byte，计算方法和 UDP 的一样对报头、数据和概念上的伪报头进行校验，只是需要把 UDP 协议号 17 改为 TCP 协议号 6,且校验和是强制性的<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125111128.png" width="auto" height="auto" alt/></li>
<li>Options，0~40 Bytes，选项长度可变，最长可扩展到 40 字节以容纳可以指定的最长 TCP 头.
<ul>
<li>必须是 4 Bytes 的倍数，不足的用 0 补充。</li>
<li>允许主机规定 MSS, Maximum Segment Size，即允许对方发来的 TCP segment 中 数据 部分的最大长度。否则默认为536字节的负载,即536+20的TCPsegment</li>
<li>window scale option允许发送方和接收方在连接开始时协商window scale factor</li>
<li>timestamp option 携带由发送方发送并由接收方回显的时间戳</li>
<li>sack 选择性确认选项 补充序号确认</li>
</ul>
</li>
</ul>
<h4 id="tcp-connection">TCP Connection<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp-connection" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<h6 id="example">example<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#example" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125121028.png" width="auto" height="auto" alt/><br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125121047.png" width="auto" height="auto" alt/><br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125122655.png" width="auto" height="auto" alt/></p>
<blockquote>
<ul>
<li>注意seq跟字节流序列号有关,seq代表的起始字符也要包括进去.如果发送的是nodata的</li>
<li>开头的syn segment是占seq的</li>
</ul>
</blockquote>
<h5 id="establishment"><strong>Establishment</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#establishment" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<ul>
<li>三次握手其实就是双方交换 ISN 的过程<img src="https://cdn.nlark.com/yuque/0/2021/png/641515/1638369915053-24cfff79-5a51-42ac-ba0a-694ff776b5ff.png" alt/></li>
<li>过程<img src="https://cdn.nlark.com/yuque/0/2021/png/641515/1638370586797-63e77f83-42ff-4ea8-97ca-9c7ca265beee.png" alt/></li>
</ul>
<ol>
<li><span class="text-highlight">SYN segment</span> 不能携带数据,只有报头（即<strong>前两次握手</strong>），但是要消耗掉 1 个 seq,以便于明确地被确认。
<ul>
<li>request 客户端向服务器发送请求段
<ol>
<li>初始序列号<span class="orange-comment">[每个主机选择的初始序列号会循环使用但是周期很长.这个规则是为了防止延迟的重复数据包]</span>
<ul>
<li><strong>因为是每个主机单独生成的所以两边的序列号没有任何关系</strong></li>
</ul>
</li>
<li>syn位为1 指示该segment包含客户端使用的初始序列号</li>
<li>最大段大小:包含在option字段中 <span class="orange-comment">[最大数据块限制]</span></li>
<li>接收窗口大小:包含在窗口大小字段中<span class="orange-comment">[未确认数据限制]</span></li>
</ol>
</li>
<li>reply 服务器发送应答段来响应客户端
<ul>
<li>前四条同上</li>
</ul>
<ol start="5">
<li>确认号,客户端发送的request段中的初始序列号+1作为序列号,表示服务器期望从客户端接收的下一个数据字节的序列号</li>
<li>ack位置1 向客户端标名当前段中的确认号字段是有效的</li>
</ol>
</li>
</ul>
</li>
<li>接收reply段之后
<ul>
<li>通过发送纯确认来确认服务器的响应<span class="orange-comment">[不必要,因为如果客户端立即发送数据包,那么就视为已经被确认,全双工连接已建立,所以其实实际上必要的是2次握手]</span></li>
</ul>
</li>
</ol>
<ul>
<li>对于除请求段以外的所有段,ack位始终置为1<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125113204.png" width="auto" height="auto" alt/></li>
</ul>
<h6 id="syn-flood-attack">SYN flood attack<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#syn-flood-attack" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<ul>
<li>由于服务端在第 2 次握手时分配了资源，因此有可能受到 <strong>SYN 泛洪攻击</strong>
<ul>
<li><span class="orange-comment">[发reply包的时候需要记住自己发出去的seq,以便于后面检查ack是否等于seq+1.]</span>因此恶意发送者可以通过发送一连串 SYN 段并且从不完成连接来占用主机上的资源
<ul>
<li>解决办法:用SYN cookies 通过加密算法,用自身的一些信息生成序列号.那么序列号+1被返回的时候,就可以通过相同的加密算法生成正确的序列号再来对比.<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125115057.png" width="auto" height="auto" alt/></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="如何寻找相关字段">如何寻找相关字段<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#如何寻找相关字段" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125113545.png" width="auto" height="auto" alt/></p>
<ul>
<li>
<p><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125114307.png" width="auto" height="auto" alt/>在wireshark里可以找到ip头的totallength为34<span>→</span>换算10进制52=ip头20 tcp头32  <a href="../.././../tags/待解决" class="tag-link internal alias" data-slug="tags/待解决">待解决</a></p>
<ul>
<li><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125114358.png" width="auto" height="auto" alt/></li>
</ul>
</li>
<li>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/641515/1638372545892-dd7f413a-5c81-4657-b9ed-0d1b361180e0.png" alt/></p>
</li>
<li>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/641515/1638372492565-2b434cbb-dfa7-4364-ba3a-b3e397f41342.png" alt/></p>
</li>
</ul>
<h5 id="release"><strong>Release</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#release" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/641515/1638379920352-2ced8782-7bf2-4e01-8e9f-c8d7153a08ec.jpeg" alt/></p>
<ul>
<li>2-army problem：理论上无法保证一定能成功释放连接。</li>
<li>假设客户端和服务端之间已经建立了良好的TCP连接,客户端想要终止连接
<ol>
<li>为了终止连接
<ol>
<li>客户端向服务单发送FIN segment FIN位设为1</li>
<li>客户端进入FIN_WAIT_1状态</li>
<li>客户端等待来自服务端的确认</li>
</ol>
</li>
<li>接收到FIN segment之后
<ol>
<li>服务器释放其接收缓冲区</li>
<li>服务端向客户端发送确认</li>
<li>服务器进入CLOSE_WAIT状态</li>
</ol>
</li>
<li>客户端收到确认后进入FIN_WAIT_2状态
<ol>
<li>客户端到服务端的连接已终止,即单向连接已关闭</li>
<li>由于服务器缓冲区已释放,客户端无法向服务器发送人恩赫数据</li>
<li>仍然可以从客户端向服务器发送纯确认(无数据)</li>
<li>服务器到客户端的连接仍然打开,服务器可以向客户端发送数据和确认信息</li>
</ol>
</li>
<li>服务器想要关闭与客户端的连接
<ol>
<li>服务器向客户端发送一个FIN segment</li>
<li>等待确认</li>
</ol>
</li>
<li>接收到FIN segment之后
<ol>
<li>客户端释放其接收缓冲区</li>
<li>客户端向服务器发送纯确认(不必须)</li>
<li>客户端进入TIME_WAIT状态
<ol>
<li>允许客户端在最终的确认丢失时重新发送,等待结束后,连接就被正式关闭</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h6 id="建模">建模<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#建模" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125120614.png" width="auto" height="auto" alt/><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251125120601.png" width="auto" height="auto" alt/></p>
<ul>
<li>TCP connection management finite state machine. The heavy solid line is the normal path for a client. The heavy dashed line is the normal path for a server. The light lines are unusual events. Each transition is labeled with the event causing it and the action resulting from it, separated by a slash.</li>
</ul>
<h4 id="可靠传输机制">可靠传输机制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#可靠传输机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<h5 id="tcp-timer-management">TCP Timer Management<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp-timer-management" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<h6 id="rto">RTO<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#rto" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<ol>
<li><strong>超时重传theRTO</strong>。TCP 发送方维护一个 Time-Out Timer，如果超过超时重传时间 RTO, Retransmission Time-Out 就重新发送这个 segment。值得讨论的问题是 RTO 的设置，TCP 面临着一个根本不同的环境。TCP 确认返回所需时间的概率分布更大且更具变异性,因此RTO的设置和传输层的不同。
<ol>
<li><span class="orange-comment">[使用动态算法，根据对网络性能的持续测量，不断调整超时间隔.]</span>这里的算法要用基本四则运算,可以用移位寄存器进行实现,很效率.
<ol>
<li>先算一个SRTT,用历史值和当前值做一个线性加权和,做一个估计的smoothRTT<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202102301.png" width="auto" height="auto" alt/></li>
<li>再算一个RTTVAR叫往返时间变异,用RTTVAR和SRTT算一个RTO,然后把这个RTO和1sec取最小值<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202102353.png" width="auto" height="auto" alt/></li>
<li>karn算法: 不对任何已被重传的segments更新估计值.此外,每次连续重传的时候超时时间都会加倍直到第一次成功通过为止</li>
</ol>
</li>
</ol>
</li>
</ol>
<h6 id="the-persistent-timer">the persistent timer<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-persistent-timer" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>接收方发送一个窗口大小为 0 的确认，告诉发送方等待。之后，接收方更新窗口，但是包含更新的数据包丢失了。现在发送方和接收方各自等待对方做些什么。</p>
<ul>
<li>当持久计时器超时时，发送方向接收方发送一个探测。对探测的响应给出窗口大小。
<ul>
<li>如果仍然为0,再次设置持久计时器</li>
<li>如果非零就可以发送数据</li>
</ul>
</li>
</ul>
<h6 id="the-keepalive-timer">the keepalive timer<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-keepalive-timer" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>当连接长时间空闲时，保活计时器可能会触发，使一方检查另一方是否仍然存在</p>
<h6 id="the-timewait-timer">the TIMEWAIT timer<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-timewait-timer" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>在关闭时的timewait状态中使用.运行的时间是 twice the maximum packet lifetime,以确保当连接关闭时,创建的所有数据包都已经消失</p>
<h5 id="流量控制滑动窗口">流量控制/滑动窗口<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#流量控制滑动窗口" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<p><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202100602.png" width="auto" height="auto" alt/></p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2021/png/641515/1638382192566-6c159d4b-3c65-4177-a418-1275ee2b26d1.png" alt/></li>
<li>窗口探测使用的计时器是 persistence timer。</li>
</ul>
<h6 id="the-silly-window-syndrome">The Silly Window Syndrome<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-silly-window-syndrome" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>当数据以大块形式传递给发送 TCP 实体，但接收端的交互式应用程序每次只读取 1 个字节时，就会出现此问题</p>
<ol>
<li>
<p>Nagle’s Algorithm</p>
<ul>
<li>减少接收方对网络造成的负载</li>
<li>减少发送多个短数据包的发送方使用的带宽</li>
<li>发一块并缓冲其余所有数据,直到第一块被确认之后,在一个tcp段中发送所有缓冲数据,并开始缓冲直到下一个段被确认</li>
<li>但是不适合交互式游戏而且可能会和延迟确认相互作用导致死锁</li>
</ul>
</li>
<li>
<p>Clark’s Solution</p>
<ul>
<li>强制接收器等待，直到有足够的可用空间，然后通告该空间<br/>
这两种解决方案都是有效的，可以一起使用。目标是使发送方不发送小段，接收方也不请求小段。</li>
</ul>
</li>
</ol>
<h6 id="乱序到达问题">乱序到达问题<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#乱序到达问题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<ul>
<li>接收方将缓冲数据，直到能够按顺序将其传递给应用层。</li>
<li>只有当已收到确认字节之前的所有数据时，才能发送确认<span class="orange-comment">[cumulative acknowledgement累积确认]</span>
<ul>
<li>如果接收方收到segments0124567,可以确认sement2中最后一个字节及其之前的所有内容.</li>
<li>当发送方timesout之后,会重新传输段3.因为接收方已经缓冲了4~7,所以收到3之后,它可以确认分段7末尾的所有字节.</li>
</ul>
</li>
</ul>
<h5 id="拥塞控制">拥塞控制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#拥塞控制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h5>
<ul>
<li>
<p>网络层在路由器队列增长过大时检测到拥塞，并尝试对其进行管理，至少通过丢弃数据包来管理。</p>
</li>
<li>
<p>传输层负责从网络层接收拥塞反馈，并减慢其向网络发送的流量速率。</p>
<ul>
<li>在互联网中，TCP 在控制拥塞以及可靠传输中都扮演主要角色。</li>
</ul>
</li>
<li>
<p>TCP 拥塞控制基于 <strong>AIMD (Additive Increase Multiplicative Decrease)</strong> 控制律使用窗口机制，以<strong>packet loss</strong>作为二进制信号。</p>
</li>
<li>
<p>TCP 维护一个拥塞窗口congestion window (the sending window）和一个流量控制窗口（接收窗口）</p>
<ul>
<li><span class="text-highlight">拥塞窗口（发送窗口）</span>的大小是指发送者在任何时刻可以在网络中传输的字节数。
<ul>
<li>拥塞窗口仅为发送者所知，不通过链路传输。</li>
<li>The corresponding rate 是窗口大小(两个窗口取最小) 除以连接的往返时间。</li>
<li>TCP 根据 AIMD 规则调整拥塞窗口的大小</li>
</ul>
</li>
<li><span class="text-highlight">流量控制窗口(接收窗口)</span>
<ul>
<li>指定接收器可以缓冲的字节数。接收器通过 TCP 头向发送器指示其窗口大小(window size)。</li>
<li>两个窗口并行跟踪，可以发送的字节数是两个窗口中较小的那个。换句话说，发送器处未确认数据的数量 ≤ min(接收器窗口大小，拥塞窗口大小)</li>
<li>如果拥塞窗口或流量控制窗口暂时满了，TCP 将停止发送数据。</li>
</ul>
</li>
<li>所有互联网 TCP 算法都假设丢包是由拥塞引起的，并通过监测超时来判断。但是，使用丢包作为拥塞信号取决于传输错误相对较少
<ul>
<li>对于无线传输链路来说,通常不成立,丢包一般是传输错误导致的</li>
<li>大多数电线和光纤的比特错误率较低</li>
</ul>
</li>
</ul>
</li>
<li>
<p>两个重要问题</p>
<ul>
<li>发送方将使用的数据包传输速率
<ul>
<li>Ack clock to estimate RTT</li>
</ul>
</li>
<li>拥塞窗口的大小so that we can take the most advantage of the network path while at the same time will not induce clog quickly
<ul>
<li>slow start</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="ack-clock">Ack clock<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ack-clock" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>确认返回到发送方的速率大约与数据包能够在路径中最慢链路上发送的速率相同<span class="orange-comment">[就是最瓶颈的那一段]</span>。这正好是发送方想要使用的速率。<br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202105701.png" width="auto" height="auto" alt/></p>
<h6 id="慢开始和拥塞避免">慢开始和拥塞避免<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#慢开始和拥塞避免" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>整个思想是让 TCP 连接的拥塞窗口长时间保持在最优值附近——既不会小到导致吞吐量过低，也不会大到引起拥塞。<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202110900.png" width="auto" height="auto" alt/><br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202110906.png" width="auto" height="auto" alt/></p>
<ul>
<li>发送方的窗口大小需要考虑两方面因素
<ol>
<li>接收方缓冲区剩余大小，即协议中发回的 rwnd；</li>
<li>网络的拥塞情况，发送方应当根据拥塞情况维护一个拥塞窗口 cwnd。</li>
</ol>
</li>
<li>发送方的窗口大小应取这二者之间的较小值。下面讨论 cwnd 的算法。
<ol>
<li>初始 cwnd 为 1（单位为 KB 或者 MSS, Maximum Segment Size）</li>
<li>每收到一个ACK,就增加一个数据包,也就是一个变两个<span class="orange-comment">[指数增长]</span><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202110719.png" width="auto" height="auto" alt/></li>
<li>指数增长到<strong>小于等于 ssthresh（slow start threshold）后</strong>开始两者每次共同 +1<span class="orange-comment">[到达阈值之后转变为线性增长]</span>最初，慢启动阈值被任意设置为较高的值，即流量控制窗口的大小，以便不会限制连接。<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202110734.png" width="auto" height="auto" alt/></li>
<li><strong>直到发现拥塞时</strong>(发现丢包) cwnd = 1, ssthresh *= 0.5,然后重新开始.</li>
<li>将 cwnd 置为 1 的考量是让网络迅速消化掉拥塞在网络中的数据包。</li>
</ol>
</li>
</ul>
<h6 id="快重传和快恢复">快重传和快恢复<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#快重传和快恢复" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/641515/1638384071833-fb93410d-f9b5-4ffb-b43a-4711ceec300d.jpeg" alt/></p>
<ul>
<li>Duplicate ACKnowledgements重复确认
<ul>
<li>会提示数据未到达的情况.<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202111514.png" width="auto" height="auto" alt/></li>
</ul>
</li>
<li>快重传<span class="orange-comment">[TCP Tahoe 版本]</span>和快恢复<span class="orange-comment">[TCP Reno版本=TCP Tahoe+快恢复]</span>是对前述算法的优化。
<ul>
<li><span class="text-highlight">快速重传:</span> 此时发送方可以不必等待超时而是一旦收到 3 个重复 ACK，发送方<strong>立刻重传</strong> 2 号 segment
<ul>
<li>慢启动阈值仍设置为当前拥塞窗口的一半。通过将拥塞窗口设置为一个数据包可以重新启动慢启动。</li>
</ul>
</li>
<li>在<span class="text-highlight">快恢复</span>算法中，我们发现 3 个冗余 ACK 时会采取 cwnd *= 0.5，ssthresh *= 0.5 的方式，而不是将 cwnd 置为 1。
<ul>
<li>对每个额外的重复确认继续发送一个新数据包（假装进一步的重复 ACK 是预期的 ACK）</li>
<li>为此，对重复 ACK 进行计数（包括触发快速重传的三个 ACK），直到网络中的数据包数量下降到新的阈值<span class="orange-comment">[下降到新阈值之前停止发送新数据包,下降到新阈值之后可以每收到一个重复确认就发送一个新的数据包]</span>
<ul>
<li>当 ACK 跳跃时协调视图采取这一策略的考量是，既然发送方还能收到冗余的 ACK，那么说明网络还没那么拥塞。<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202112612.png" width="auto" height="auto" alt/></li>
</ul>
</li>
<li>快速重传之后的一个RTT,丢失的数据包将被确认,那么重复确认流停止,退出快速恢复模式.拥塞窗口将被设置为新的慢启动窗口并线性增长.</li>
<li>TCP 避免使用慢启动，除非在连接首次启动时和发生超时时。<br/>
<img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202113044.png" width="auto" height="auto" alt/><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202113054.png" width="auto" height="auto" alt/><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202113112.png" width="auto" height="auto" alt/><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202113126.png" width="auto" height="auto" alt/></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="其他">其他<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#其他" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p>SACK (Selective ACKnowledgements):</p>
<ul>
<li>lists up to three ranges of bytes that have been received. With this information, the sender can more directly decide which packets to retransmit and track the packets in flight to implement the congestion window.</li>
<li>With SACK, TCP can recover more easily from situations in which multiple packets are lost at roughly the same time, since the TCP sender knows which packets have not been received.</li>
<li><span class="orange-comment">[RFC2883 and RFC3517]</span></li>
</ul>
<p>ECN (Explicit Congestion Notification)</p>
<ul>
<li>ECN is an IP layer mechanism to 通知主机网络拥塞情况</li>
<li>The use of ECN is enabled for a TCP connection when both the sender and receiver indicate that they are capable of using ECN by setting theECE and CWR bits during the connection establishment.
<ul>
<li>The TCP receiver uses the ECE (ECN-Echo) flag to signal the TCP sender to tell it to slow down when the TCP receiver gets a congestion indication from the network.</li>
<li>The sender tells the receiver that it has heard the signal by using the CWR (Congestion Window Reduced) flag, so that the TCP receiver knows the sender has slowed down and can stop sending the ECN-Echo.</li>
</ul>
</li>
<li>If ECN is used, routers that support ECN will set a congestion signal on packets that can carry ECN flags when congestion is approaching, instead of dropping those packets after congestion has occurred.</li>
<li>ECN requires both host and router support. <span class="orange-comment">[RFC 3168]</span></li>
</ul>
<h6 id="其他其他-bbr基于拥塞的拥塞控制">其他其他: bbr基于拥塞的拥塞控制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#其他其他-bbr基于拥塞的拥塞控制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h6>
<p><img src="../../课程笔记/计算机网络/attachments/Pasted-image-20251202115553.png" width="auto" height="auto" alt/></p>
<ul>
<li>当瓶颈缓冲区很大时，基于丢包的拥塞控制会将其保持满满状态，导致缓冲区膨胀 buffer bloat。
<ul>
<li>延迟拥塞事件对发送方的影响（当长网络路径中的网络设备具有过大的缓冲区时，具有大拥塞窗口的 TCP 发送方可以以远超网络容量的速率发送数据，直到收到丢包信号才会做出反应）。</li>
</ul>
</li>
<li>当瓶颈缓冲区较小时，基于丢包的拥塞控制会错误地将丢包解释为拥塞信号，导致吞吐量很低。</li>
</ul>
<p>替代方案:<br/>
首先理解网络拥塞在何处产生以及如何产生</p>
<ul>
<li>在任何时间，一条全双工 TCP 连接在每个方向上恰好有一条最慢的链路或瓶颈。
<ul>
<li>瓶颈决定了连接的最大数据传输速率</li>
<li>它是持久队列形成的地方</li>
</ul>
</li>
<li>从 TCP 的角度来看，一条任意复杂的路径表现为具有相同 RTT 和瓶颈速率的单条链路。
<ul>
<li>两个物理约束，RTprop（往返传播延迟）和 BtlBw（瓶颈带宽）限制了传输性能。
<ul>
<li>如果网络路径是一条物理管道，RTprop 就是它的长度，BtlBW 就是它的最小直径。</li>
</ul>
</li>
</ul>
</li>
</ul></article><hr/><div class="page-footer"><div class="giscus" data-repo="im0x0ing/im0x0ing.github.io" data-repo-id="R_kgDOQevgrA" data-category="Announcements" data-category-id="DIC_kwDOQevgrM4CzLI8" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-input-position="top" data-light-theme="light" data-dark-theme="dark" data-theme-url="https://im0x0ing.github.io/static/giscus" data-lang="zh-CN"></div></div></div><div class="right sidebar"><div class="toc desktop-only"><button type="button" class="toc-header" aria-controls="toc-97" aria-expanded="true"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div class="toc-depth-control"><span class="depth-label">H3</span><input type="range" class="depth-slider" min="1" max="6" value="2" step="1"/></div><ul id="list-9" class="toc-content overflow"><li class="depth-0"><a href="#传输层的功能" data-for="传输层的功能">传输层的功能</a></li><li class="depth-0"><a href="#udp" data-for="udp">UDP</a></li><li class="depth-2"><a href="#rtp-实时传输协议不怎么考" data-for="rtp-实时传输协议不怎么考">RTP 实时传输协议[不怎么考]</a></li><li class="depth-2"><a href="#rtcp-实时传输控制协议" data-for="rtcp-实时传输控制协议">RTCP 实时传输控制协议</a></li><li class="depth-0"><a href="#tcp" data-for="tcp">TCP</a></li><li class="depth-1"><a href="#tcp-segment" data-for="tcp-segment">TCP Segment</a></li><li class="depth-1"><a href="#tcp-connection" data-for="tcp-connection">TCP Connection</a></li><li class="depth-3"><a href="#example" data-for="example">example</a></li><li class="depth-2"><a href="#establishment" data-for="establishment">Establishment</a></li><li class="depth-3"><a href="#syn-flood-attack" data-for="syn-flood-attack">SYN flood attack</a></li><li class="depth-3"><a href="#如何寻找相关字段" data-for="如何寻找相关字段">如何寻找相关字段</a></li><li class="depth-2"><a href="#release" data-for="release">Release</a></li><li class="depth-3"><a href="#建模" data-for="建模">建模</a></li><li class="depth-1"><a href="#可靠传输机制" data-for="可靠传输机制">可靠传输机制</a></li><li class="depth-2"><a href="#tcp-timer-management" data-for="tcp-timer-management">TCP Timer Management</a></li><li class="depth-3"><a href="#rto" data-for="rto">RTO</a></li><li class="depth-3"><a href="#the-persistent-timer" data-for="the-persistent-timer">the persistent timer</a></li><li class="depth-3"><a href="#the-keepalive-timer" data-for="the-keepalive-timer">the keepalive timer</a></li><li class="depth-3"><a href="#the-timewait-timer" data-for="the-timewait-timer">the TIMEWAIT timer</a></li><li class="depth-2"><a href="#流量控制滑动窗口" data-for="流量控制滑动窗口">流量控制/滑动窗口</a></li><li class="depth-3"><a href="#the-silly-window-syndrome" data-for="the-silly-window-syndrome">The Silly Window Syndrome</a></li><li class="depth-3"><a href="#乱序到达问题" data-for="乱序到达问题">乱序到达问题</a></li><li class="depth-2"><a href="#拥塞控制" data-for="拥塞控制">拥塞控制</a></li><li class="depth-3"><a href="#ack-clock" data-for="ack-clock">Ack clock</a></li><li class="depth-3"><a href="#慢开始和拥塞避免" data-for="慢开始和拥塞避免">慢开始和拥塞避免</a></li><li class="depth-3"><a href="#快重传和快恢复" data-for="快重传和快恢复">快重传和快恢复</a></li><li class="depth-3"><a href="#其他" data-for="其他">其他</a></li><li class="depth-3"><a href="#其他其他-bbr基于拥塞的拥塞控制" data-for="其他其他-bbr基于拥塞的拥塞控制">其他其他: bbr基于拥塞的拥塞控制</a></li><li class="overflow-end"></li></ul></div><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div class="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button class="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div class="global-graph-outer"><div class="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.2,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.5.2</a> © 2026</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript" data-persist="true">function n(){let t=this.parentElement;t.classList.toggle("is-collapsed");let e=t.getElementsByClassName("callout-content")[0];if(!e)return;let l=t.classList.contains("is-collapsed");e.style.gridTemplateRows=l?"0fr":"1fr"}function c(){let t=document.getElementsByClassName("callout is-collapsible");for(let e of t){let l=e.getElementsByClassName("callout-title")[0],s=e.getElementsByClassName("callout-content")[0];if(!l||!s)continue;l.addEventListener("click",n),window.addCleanup(()=>l.removeEventListener("click",n));let o=e.classList.contains("is-collapsed");s.style.gridTemplateRows=o?"0fr":"1fr"}}document.addEventListener("nav",c);
</script><script type="module" data-persist="true">function f(i,e){if(!i)return;function r(o){o.target===this&&(o.preventDefault(),o.stopPropagation(),e())}function t(o){o.key.startsWith("Esc")&&(o.preventDefault(),e())}i?.addEventListener("click",r),window.addCleanup(()=>i?.removeEventListener("click",r)),document.addEventListener("keydown",t),window.addCleanup(()=>document.removeEventListener("keydown",t))}function y(i){for(;i.firstChild;)i.removeChild(i.firstChild)}var h=class{constructor(e,r){this.container=e;this.content=r;this.setupEventListeners(),this.setupNavigationControls(),this.resetTransform()}isDragging=!1;startPan={x:0,y:0};currentPan={x:0,y:0};scale=1;MIN_SCALE=.5;MAX_SCALE=3;cleanups=[];setupEventListeners(){let e=this.onMouseDown.bind(this),r=this.onMouseMove.bind(this),t=this.onMouseUp.bind(this),o=this.resetTransform.bind(this);this.container.addEventListener("mousedown",e),document.addEventListener("mousemove",r),document.addEventListener("mouseup",t),window.addEventListener("resize",o),this.cleanups.push(()=>this.container.removeEventListener("mousedown",e),()=>document.removeEventListener("mousemove",r),()=>document.removeEventListener("mouseup",t),()=>window.removeEventListener("resize",o))}cleanup(){for(let e of this.cleanups)e()}setupNavigationControls(){let e=document.createElement("div");e.className="mermaid-controls";let r=this.createButton("+",()=>this.zoom(.1)),t=this.createButton("-",()=>this.zoom(-.1)),o=this.createButton("Reset",()=>this.resetTransform());e.appendChild(t),e.appendChild(o),e.appendChild(r),this.container.appendChild(e)}createButton(e,r){let t=document.createElement("button");return t.textContent=e,t.className="mermaid-control-button",t.addEventListener("click",r),window.addCleanup(()=>t.removeEventListener("click",r)),t}onMouseDown(e){e.button===0&&(this.isDragging=!0,this.startPan={x:e.clientX-this.currentPan.x,y:e.clientY-this.currentPan.y},this.container.style.cursor="grabbing")}onMouseMove(e){this.isDragging&&(e.preventDefault(),this.currentPan={x:e.clientX-this.startPan.x,y:e.clientY-this.startPan.y},this.updateTransform())}onMouseUp(){this.isDragging=!1,this.container.style.cursor="grab"}zoom(e){let r=Math.min(Math.max(this.scale+e,this.MIN_SCALE),this.MAX_SCALE),t=this.content.getBoundingClientRect(),o=t.width/2,n=t.height/2,c=r-this.scale;this.currentPan.x-=o*c,this.currentPan.y-=n*c,this.scale=r,this.updateTransform()}updateTransform(){this.content.style.transform=`translate(${this.currentPan.x}px, ${this.currentPan.y}px) scale(${this.scale})`}resetTransform(){this.scale=1;let e=this.content.querySelector("svg");this.currentPan={x:e.getBoundingClientRect().width/2,y:e.getBoundingClientRect().height/2},this.updateTransform()}},C=["--secondary","--tertiary","--gray","--light","--lightgray","--highlight","--dark","--darkgray","--codeFont"],E;document.addEventListener("nav",async()=>{let e=document.querySelector(".center").querySelectorAll("code.mermaid");if(e.length===0)return;E||=await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.esm.min.mjs");let r=E.default,t=new WeakMap;for(let n of e)t.set(n,n.innerText);async function o(){for(let s of e){s.removeAttribute("data-processed");let a=t.get(s);a&&(s.innerHTML=a)}let n=C.reduce((s,a)=>(s[a]=window.getComputedStyle(document.documentElement).getPropertyValue(a),s),{}),c=document.documentElement.getAttribute("saved-theme")==="dark";r.initialize({startOnLoad:!1,securityLevel:"loose",theme:c?"dark":"base",themeVariables:{fontFamily:n["--codeFont"],primaryColor:n["--light"],primaryTextColor:n["--darkgray"],primaryBorderColor:n["--tertiary"],lineColor:n["--darkgray"],secondaryColor:n["--secondary"],tertiaryColor:n["--tertiary"],clusterBkg:n["--light"],edgeLabelBackground:n["--highlight"]}}),await r.run({nodes:e})}await o(),document.addEventListener("themechange",o),window.addCleanup(()=>document.removeEventListener("themechange",o));for(let n=0;n<e.length;n++){let v=function(){let g=l.querySelector("#mermaid-space"),m=l.querySelector(".mermaid-content");if(!m)return;y(m);let w=c.querySelector("svg").cloneNode(!0);m.appendChild(w),l.classList.add("active"),g.style.cursor="grab",u=new h(g,m)},M=function(){l.classList.remove("active"),u?.cleanup(),u=null},c=e[n],s=c.parentElement,a=s.querySelector(".clipboard-button"),d=s.querySelector(".expand-button"),p=window.getComputedStyle(a),L=a.offsetWidth+parseFloat(p.marginLeft||"0")+parseFloat(p.marginRight||"0");d.style.right=`calc(${L}px + 0.3rem)`,s.prepend(d);let l=s.querySelector("#mermaid-container");if(!l)return;let u=null;d.addEventListener("click",v),f(l,M),window.addCleanup(()=>{u?.cleanup(),d.removeEventListener("click",v)})}});
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript" data-persist="true"></script><script src="../../postscript.js" type="module" data-persist="true"></script></html>